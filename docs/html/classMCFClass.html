<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MCFClass Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classMCFClass.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classMCFClass-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MCFClass Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__MCFCLASS__CLASSES.html">Classes in MCFClass.h</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This abstract base class defines a standard interface for (linear or convex quadartic separable) Min Cost Flow (MCF) problem solvers.  
 <a href="classMCFClass.html#details">More...</a></p>

<p><code>#include &lt;MCFClass.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MCFClass:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMCFClass.png" usemap="#MCFClass_map" alt=""/>
  <map id="MCFClass_map" name="MCFClass_map">
<area href="classCS2.html" title="The CS2 class derives from the abstract base class MCFClass, thus sharing its (standard) interface..." alt="CS2" shape="rect" coords="0,56,83,80"/>
<area href="classMCFCplex.html" title="The MCFCplex class derives from the abstract base class MCFClass, thus sharing its (standard) interfa..." alt="MCFCplex" shape="rect" coords="93,56,176,80"/>
<area href="classMCFSimplex.html" title="The MCFSimplex class derives from the abstract base class MCFClass, thus sharing its (standard) inter..." alt="MCFSimplex" shape="rect" coords="186,56,269,80"/>
<area href="classMCFZIB.html" title="The MCFZIB class derives from the abstract base class MCFClass, thus sharing its (standard) interface..." alt="MCFZIB" shape="rect" coords="279,56,362,80"/>
<area href="classRelaxIV.html" title="The RelaxIV class derives from the abstract base class MCFClass, thus sharing its (standard) interfac..." alt="RelaxIV" shape="rect" coords="372,56,455,80"/>
<area href="classSPTree.html" title="The SPTree class derives from the abstract base class MCFClass, thus sharing its (standard) interface..." alt="SPTree" shape="rect" coords="465,56,548,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass_1_1MCFException.html">MCFException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small class for exceptions.  <a href="classMCFClass_1_1MCFException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass_1_1MCFState.html">MCFState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for representing the internal state of the MCF algorithm.  <a href="classMCFClass_1_1MCFState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> defines four main public types:</p>
<ul>
<li>Index, the type of arc and node indices;</li>
<li>FNumber, the type of flow variables, arc capacities, and node deficits;</li>
<li>CNumber, the type of flow costs, node potentials, and arc reduced costs;</li>
<li>FONumber, the type of objective function value.</li>
</ul>
<p>By re-defining the types in this section, most MCFSolver should be made to work with any reasonable choice of data type (= one that is capable of properly representing the data of the instances to be solved). This may be relevant due to an important property of MCF problems: <em>if all arc capacities and node deficits are integer, then there exists an integral optimal primal solution</em>, and <em>if all arc costs are integer, then there exists an integral optimal dual solution</em>. Even more importantly, <em>many solution algorithms will in fact produce an integral primal/dual solution for free</em>, because <em>every primal/dual solution they generate during the solution process is naturally integral</em>. Therefore, one can use integer data types to represent everything connected with flows and/or costs if the corresponding data is integer in all instances one needs to solve. This directly translates in significant memory savings and/or speed improvements.</p>
<p>It is the user's responsibility to ensure that these types are set to reasonable values*. So, the experienced user may want to experiment with setting this data properly if memory footprint and/or speed is a primary concern. Note, however, that <em>not all solution algorithms will happily accept integer data</em>; one example are Interior-Point approaches, which require both flow and cost variables to be continuous (float). So, the viability of setting integer data (as well as its impact on performances) is strictly related to the specific kind of algorithm used. Since these types are common to all derived classes, they have to be set taking into account the needs of all the solvers that are going to be used, and adapting to the "worst case"; of course, FNumber == CNumber == double is going to always be an acceptable "worst case" setting. <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> may in a future be defined as a template class, with these as template parameters, but this is currently deemed overkill and avoided.</p>
<p>Finally, note that the above integrality property only holds for <em>linear</em> MCF problems. If any arc has a nonzero quadratic cost coefficient, optimal flows and potentials may be fractional even if all the data of the problem (comprised quadratic cost coefficients) is integer. Hence, for <em>quadratic</em> MCF solvers, a setting like FNumber == CNumber == double is actually mandatory*, for any reasonable algorithm will typically misbehave otherwise. </p>
</div></td></tr>
<tr class="memitem:af6e60cb841150361862d6b895c523e0a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af6e60cb841150361862d6b895c523e0a">MCFParam</a> { <br />
&#160;&#160;<a class="el" href="classMCFClass.html#af6e60cb841150361862d6b895c523e0aab35d3e473676b56fa123d6df3d855aa0">kMaxTime</a> = 0, 
<a class="el" href="classMCFClass.html#af6e60cb841150361862d6b895c523e0aa50d3edcd55bc1dd84d4e1719430f9d20">kMaxIter</a>, 
<a class="el" href="classMCFClass.html#af6e60cb841150361862d6b895c523e0aa753a94f6a06a5579eb0855479dfbb6b1">kEpsFlw</a>, 
<a class="el" href="classMCFClass.html#af6e60cb841150361862d6b895c523e0aa409d9ed5655d184667a5e486e5110c6e">kEpsDfct</a>, 
<br />
&#160;&#160;<a class="el" href="classMCFClass.html#af6e60cb841150361862d6b895c523e0aaf263085cb23be60527c92896891cd12c">kEpsCst</a>, 
<a class="el" href="classMCFClass.html#af6e60cb841150361862d6b895c523e0aa7efdbe01bec821f08a391f9542086475">kReopt</a>, 
<a class="el" href="classMCFClass.html#af6e60cb841150361862d6b895c523e0aa99ac8339170db67bf9af4a60362ef7e1">kLastParam</a>
<br />
 }</td></tr>
<tr class="memdesc:af6e60cb841150361862d6b895c523e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public enum describing the possible parameters of the MCF solver, to be used with the methods <a class="el" href="classMCFClass.html#ab8e162715d8454f30679c10372db4db8" title="Set integer parameters of the algorithm. ">SetPar()</a> and <a class="el" href="classMCFClass.html#ac66ea95b63fe61ce67e0f8544f200887" title="This method returns one of the integer parameter of the algorithm. ">GetPar()</a>.  <a href="classMCFClass.html#af6e60cb841150361862d6b895c523e0a">More...</a><br /></td></tr>
<tr class="separator:af6e60cb841150361862d6b895c523e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ef269c5dd98eea5274eb03a3feb5fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fb">MCFStatus</a> { <br />
&#160;&#160;<a class="el" href="classMCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1">kUnSolved</a> = -1, 
<a class="el" href="classMCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fba42e6b26684acf67af002df88a9cf997c">kOK</a> = 0, 
<a class="el" href="classMCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fba142714524ffdfe9cfebaa1033fd1a18f">kStopped</a>, 
<a class="el" href="classMCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fba7db95dc60f32bc33a35f748f639cc6d0">kUnfeasible</a>, 
<br />
&#160;&#160;<a class="el" href="classMCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fba4b9de95ee3087851acd98262e09f0be8">kUnbounded</a>, 
<a class="el" href="classMCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fbaacb2c04376333850bff6fb1065c0c171">kError</a>
<br />
 }</td></tr>
<tr class="memdesc:a15ef269c5dd98eea5274eb03a3feb5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public enum describing the possible status of the MCF solver.  <a href="classMCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fb">More...</a><br /></td></tr>
<tr class="separator:a15ef269c5dd98eea5274eb03a3feb5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b7f4459be059eae1a7d83a8e190c28"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28">MCFAnswer</a> { <a class="el" href="classMCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28a503f4e9dca6c8c12ea38f9e8c1be0126">kNo</a> = 0, 
<a class="el" href="classMCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28ace5b3b5f2037b0d65d161b53b7c940fe">kYes</a>
 }</td></tr>
<tr class="memdesc:ad7b7f4459be059eae1a7d83a8e190c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public enum describing the possible reoptimization status of the MCF solver.  <a href="classMCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28">More...</a><br /></td></tr>
<tr class="separator:ad7b7f4459be059eae1a7d83a8e190c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1b139bac65f5f35bdadc7549a819de"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#adb1b139bac65f5f35bdadc7549a819de">MCFFlFrmt</a> { <a class="el" href="classMCFClass.html#adb1b139bac65f5f35bdadc7549a819dea6e65d07cdd719be7d99902bb47920a37">kDimacs</a> = 0, 
<a class="el" href="classMCFClass.html#adb1b139bac65f5f35bdadc7549a819deac27a029d7010490d53e1df36b39597e6">kQDimacs</a>, 
<a class="el" href="classMCFClass.html#adb1b139bac65f5f35bdadc7549a819dea65125719fd6c68bc3904a45937fcfd85">kMPS</a>, 
<a class="el" href="classMCFClass.html#adb1b139bac65f5f35bdadc7549a819dea7efb98d1b3dfca0f601d4df644b418a0">kFWMPS</a>
 }</td></tr>
<tr class="memdesc:adb1b139bac65f5f35bdadc7549a819de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public enum describing the possible file formats in <a class="el" href="classMCFClass.html#acd008d9548bf3e1aef1291864171bb2d" title="Write the current MCF problem to an ostream. ">WriteMCF()</a>.  <a href="classMCFClass.html#adb1b139bac65f5f35bdadc7549a819de">More...</a><br /></td></tr>
<tr class="separator:adb1b139bac65f5f35bdadc7549a819de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="memItemLeft" align="right" valign="top"><a id="ad53d6229d7ec28555a9c9c2fd9abf773"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a></td></tr>
<tr class="memdesc:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="mdescLeft">&#160;</td><td class="mdescRight">index of a node or arc ( &gt;= 0 ) <br /></td></tr>
<tr class="separator:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3388eb329ff0551a0b86b6c67e33d8"><td class="memItemLeft" align="right" valign="top"><a id="ace3388eb329ff0551a0b86b6c67e33d8"></a>
typedef <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a></td></tr>
<tr class="memdesc:ace3388eb329ff0551a0b86b6c67e33d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set (array) of indices <br /></td></tr>
<tr class="separator:ace3388eb329ff0551a0b86b6c67e33d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76aaabb20535c51a2752b93f6c38fe54"><td class="memItemLeft" align="right" valign="top"><a id="a76aaabb20535c51a2752b93f6c38fe54"></a>
typedef const <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a></td></tr>
<tr class="memdesc:a76aaabb20535c51a2752b93f6c38fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only index <br /></td></tr>
<tr class="separator:a76aaabb20535c51a2752b93f6c38fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81575b2d4e4d5636b17170432150ae69"><td class="memItemLeft" align="right" valign="top"><a id="a81575b2d4e4d5636b17170432150ae69"></a>
typedef <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a></td></tr>
<tr class="memdesc:a81575b2d4e4d5636b17170432150ae69"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only index array <br /></td></tr>
<tr class="separator:a81575b2d4e4d5636b17170432150ae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea3e5951d222b2a8e57de1b4246a909"><td class="memItemLeft" align="right" valign="top"><a id="aeea3e5951d222b2a8e57de1b4246a909"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a></td></tr>
<tr class="memdesc:aeea3e5951d222b2a8e57de1b4246a909"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc flow <br /></td></tr>
<tr class="separator:aeea3e5951d222b2a8e57de1b4246a909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="memItemLeft" align="right" valign="top"><a id="a9dae1f1a39c208ce3c2b337cd5bb3d00"></a>
typedef <a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a></td></tr>
<tr class="memdesc:a9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of flows <br /></td></tr>
<tr class="separator:a9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f747fbdff346237c8db4469d569994"><td class="memItemLeft" align="right" valign="top"><a id="a11f747fbdff346237c8db4469d569994"></a>
typedef const <a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a></td></tr>
<tr class="memdesc:a11f747fbdff346237c8db4469d569994"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only flow <br /></td></tr>
<tr class="separator:a11f747fbdff346237c8db4469d569994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad325f3193dbba0ddef1da4e72d29eda6"><td class="memItemLeft" align="right" valign="top"><a id="ad325f3193dbba0ddef1da4e72d29eda6"></a>
typedef <a class="el" href="classMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a></td></tr>
<tr class="memdesc:ad325f3193dbba0ddef1da4e72d29eda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only flow array <br /></td></tr>
<tr class="separator:ad325f3193dbba0ddef1da4e72d29eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d0627ba8213afe1ec4ebeb4508e8f1"><td class="memItemLeft" align="right" valign="top"><a id="a24d0627ba8213afe1ec4ebeb4508e8f1"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a></td></tr>
<tr class="memdesc:a24d0627ba8213afe1ec4ebeb4508e8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc flow cost <br /></td></tr>
<tr class="separator:a24d0627ba8213afe1ec4ebeb4508e8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62409402be4e4b301e1a568f99f877be"><td class="memItemLeft" align="right" valign="top"><a id="a62409402be4e4b301e1a568f99f877be"></a>
typedef <a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a></td></tr>
<tr class="memdesc:a62409402be4e4b301e1a568f99f877be"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of costs <br /></td></tr>
<tr class="separator:a62409402be4e4b301e1a568f99f877be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dbefeeb08c3f63073622411893eb76"><td class="memItemLeft" align="right" valign="top"><a id="a07dbefeeb08c3f63073622411893eb76"></a>
typedef const <a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a></td></tr>
<tr class="memdesc:a07dbefeeb08c3f63073622411893eb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only cost <br /></td></tr>
<tr class="separator:a07dbefeeb08c3f63073622411893eb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab700102e9ba8bb6015be6818d4e99097"><td class="memItemLeft" align="right" valign="top"><a id="ab700102e9ba8bb6015be6818d4e99097"></a>
typedef <a class="el" href="classMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a></td></tr>
<tr class="memdesc:ab700102e9ba8bb6015be6818d4e99097"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only cost array <br /></td></tr>
<tr class="separator:ab700102e9ba8bb6015be6818d4e99097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ee7b3099b0bc780a6a4b43629488fa"><td class="memItemLeft" align="right" valign="top"><a id="af5ee7b3099b0bc780a6a4b43629488fa"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a></td></tr>
<tr class="memdesc:af5ee7b3099b0bc780a6a4b43629488fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the objective function: has to hold sums of products of FNumber(s) by CNumber(s) <br /></td></tr>
<tr class="separator:af5ee7b3099b0bc780a6a4b43629488fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7942d00ff59c58e29834ecb27d8efe0"><td class="memItemLeft" align="right" valign="top"><a id="ac7942d00ff59c58e29834ecb27d8efe0"></a>
typedef const <a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac7942d00ff59c58e29834ecb27d8efe0">cFONumber</a></td></tr>
<tr class="memdesc:ac7942d00ff59c58e29834ecb27d8efe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only o.f. value <br /></td></tr>
<tr class="separator:ac7942d00ff59c58e29834ecb27d8efe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab547218814e3b90d15f219f5aaf8b937"><td class="memItemLeft" align="right" valign="top"><a id="ab547218814e3b90d15f219f5aaf8b937"></a>
typedef <a class="el" href="classMCFClass_1_1MCFState.html">MCFState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a></td></tr>
<tr class="memdesc:ab547218814e3b90d15f219f5aaf8b937"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to a <a class="el" href="classMCFClass_1_1MCFState.html" title="Base class for representing the internal state of the MCF algorithm. ">MCFState</a> <br /></td></tr>
<tr class="separator:ab547218814e3b90d15f219f5aaf8b937"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:ac598fb1a423b3b722414a53c8549953c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac598fb1a423b3b722414a53c8549953c">MCFClass</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> nmx=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> mmx=0)</td></tr>
<tr class="memdesc:ac598fb1a423b3b722414a53c8549953c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="#ac598fb1a423b3b722414a53c8549953c">More...</a><br /></td></tr>
<tr class="separator:ac598fb1a423b3b722414a53c8549953c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other initializations</div></td></tr>
<tr class="memitem:a8d82d26f7845eb69081c860e14c3dc4c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c">LoadNet</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> nmx=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> mmx=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> pn=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> pm=0, <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> pU=0, <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> pC=0, <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> pDfct=0, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> pSn=0, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> pEn=0)=0</td></tr>
<tr class="memdesc:a8d82d26f7845eb69081c860e14c3dc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inputs a new network.  <a href="#a8d82d26f7845eb69081c860e14c3dc4c">More...</a><br /></td></tr>
<tr class="separator:a8d82d26f7845eb69081c860e14c3dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d79a2f00cf8a2416b2b3e41552e843"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a34d79a2f00cf8a2416b2b3e41552e843">LoadDMX</a> (istream &amp;DMXs, bool IsQuad=false)</td></tr>
<tr class="memdesc:a34d79a2f00cf8a2416b2b3e41552e843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a MCF instance in DIMACS standard format from the istream.  <a href="#a34d79a2f00cf8a2416b2b3e41552e843">More...</a><br /></td></tr>
<tr class="separator:a34d79a2f00cf8a2416b2b3e41552e843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0554708d9abb0e079a8d6f073def9bab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a0554708d9abb0e079a8d6f073def9bab">PreProcess</a> (void)</td></tr>
<tr class="memdesc:a0554708d9abb0e079a8d6f073def9bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a smaller/easier equivalent MCF problem.  <a href="#a0554708d9abb0e079a8d6f073def9bab">More...</a><br /></td></tr>
<tr class="separator:a0554708d9abb0e079a8d6f073def9bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e162715d8454f30679c10372db4db8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab8e162715d8454f30679c10372db4db8">SetPar</a> (int par, int val)</td></tr>
<tr class="memdesc:ab8e162715d8454f30679c10372db4db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set integer parameters of the algorithm.  <a href="#ab8e162715d8454f30679c10372db4db8">More...</a><br /></td></tr>
<tr class="separator:ab8e162715d8454f30679c10372db4db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acd81f913880873c577de03a4fa1959"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4acd81f913880873c577de03a4fa1959">SetPar</a> (int par, double val)</td></tr>
<tr class="memdesc:a4acd81f913880873c577de03a4fa1959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set float parameters of the algorithm.  <a href="#a4acd81f913880873c577de03a4fa1959">More...</a><br /></td></tr>
<tr class="separator:a4acd81f913880873c577de03a4fa1959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66ea95b63fe61ce67e0f8544f200887"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac66ea95b63fe61ce67e0f8544f200887">GetPar</a> (int par, int &amp;val) const</td></tr>
<tr class="memdesc:ac66ea95b63fe61ce67e0f8544f200887"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns one of the integer parameter of the algorithm.  <a href="#ac66ea95b63fe61ce67e0f8544f200887">More...</a><br /></td></tr>
<tr class="separator:ac66ea95b63fe61ce67e0f8544f200887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677caf4176eef1509a0fdf87c0662897"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a677caf4176eef1509a0fdf87c0662897">GetPar</a> (int par, double &amp;val) const</td></tr>
<tr class="memdesc:a677caf4176eef1509a0fdf87c0662897"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns one of the integer parameter of the algorithm.  <a href="#a677caf4176eef1509a0fdf87c0662897">More...</a><br /></td></tr>
<tr class="separator:a677caf4176eef1509a0fdf87c0662897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5441232979a0ac98410d765b04830eeb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a5441232979a0ac98410d765b04830eeb">SetMCFTime</a> (bool TimeIt=true)</td></tr>
<tr class="memdesc:a5441232979a0ac98410d765b04830eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an OPTtimers object [see OPTtypes.h] to be used for timing the methods of the class.  <a href="#a5441232979a0ac98410d765b04830eeb">More...</a><br /></td></tr>
<tr class="separator:a5441232979a0ac98410d765b04830eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Solving the problem</div></td></tr>
<tr class="memitem:ac0d96429d896a2d878a5f057535ab1ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac0d96429d896a2d878a5f057535ab1ee">SolveMCF</a> (void)=0</td></tr>
<tr class="memdesc:ac0d96429d896a2d878a5f057535ab1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver of the Min Cost Flow Problem.  <a href="#ac0d96429d896a2d878a5f057535ab1ee">More...</a><br /></td></tr>
<tr class="separator:ac0d96429d896a2d878a5f057535ab1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333e27ad7a73779b096cb70829cbe8be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be">MCFGetStatus</a> (void)</td></tr>
<tr class="memdesc:a333e27ad7a73779b096cb70829cbe8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an int describing the current status of the MCF solver.  <a href="#a333e27ad7a73779b096cb70829cbe8be">More...</a><br /></td></tr>
<tr class="separator:a333e27ad7a73779b096cb70829cbe8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading flow solution</div></td></tr>
<tr class="memitem:a884f1180138ddf3df909347b1c85428c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a884f1180138ddf3df909347b1c85428c">MCFGetX</a> (<a class="el" href="classMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> F, <a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a884f1180138ddf3df909347b1c85428c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the optimal flow solution in the vector F[].  <a href="#a884f1180138ddf3df909347b1c85428c">More...</a><br /></td></tr>
<tr class="separator:a884f1180138ddf3df909347b1c85428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb307e0707adaef99bb0e08c9e10eb8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4eb307e0707adaef99bb0e08c9e10eb8">MCFGetX</a> (void)</td></tr>
<tr class="memdesc:a4eb307e0707adaef99bb0e08c9e10eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal data structure containing the flow solution in "dense" format.  <a href="#a4eb307e0707adaef99bb0e08c9e10eb8">More...</a><br /></td></tr>
<tr class="separator:a4eb307e0707adaef99bb0e08c9e10eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4966a98c7ffa909057064beb4507a5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a7a4966a98c7ffa909057064beb4507a5">HaveNewX</a> (void)</td></tr>
<tr class="memdesc:a7a4966a98c7ffa909057064beb4507a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a different (approximately) optimal primal solution is available.  <a href="#a7a4966a98c7ffa909057064beb4507a5">More...</a><br /></td></tr>
<tr class="separator:a7a4966a98c7ffa909057064beb4507a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading potentials</div></td></tr>
<tr class="memitem:a8c573c04800332c86ea31aeb80bbd7b1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a8c573c04800332c86ea31aeb80bbd7b1">MCFGetPi</a> (<a class="el" href="classMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> P, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a8c573c04800332c86ea31aeb80bbd7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the optimal node potentials in the vector P[].  <a href="#a8c573c04800332c86ea31aeb80bbd7b1">More...</a><br /></td></tr>
<tr class="separator:a8c573c04800332c86ea31aeb80bbd7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1a95d5c707f83ffc6aecba1e7e0e10"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a8f1a95d5c707f83ffc6aecba1e7e0e10">MCFGetPi</a> (void)</td></tr>
<tr class="memdesc:a8f1a95d5c707f83ffc6aecba1e7e0e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal data structure containing the node potentials.  <a href="#a8f1a95d5c707f83ffc6aecba1e7e0e10">More...</a><br /></td></tr>
<tr class="separator:a8f1a95d5c707f83ffc6aecba1e7e0e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b2b6516a7874ac55145312bd2d55bb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a87b2b6516a7874ac55145312bd2d55bb">HaveNewPi</a> (void)</td></tr>
<tr class="memdesc:a87b2b6516a7874ac55145312bd2d55bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a different (approximately) optimal dual solution is available.  <a href="#a87b2b6516a7874ac55145312bd2d55bb">More...</a><br /></td></tr>
<tr class="separator:a87b2b6516a7874ac55145312bd2d55bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading reduced costs</div></td></tr>
<tr class="memitem:a361d84ae42041fdbf3824d45fc4c54aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a361d84ae42041fdbf3824d45fc4c54aa">MCFGetRC</a> (<a class="el" href="classMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> CR, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a361d84ae42041fdbf3824d45fc4c54aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the reduced costs corresponding to the current dual solution in RC[].  <a href="#a361d84ae42041fdbf3824d45fc4c54aa">More...</a><br /></td></tr>
<tr class="separator:a361d84ae42041fdbf3824d45fc4c54aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af027cee8179a876a4879c73820c380d1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af027cee8179a876a4879c73820c380d1">MCFGetRC</a> (void)</td></tr>
<tr class="memdesc:af027cee8179a876a4879c73820c380d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal data structure containing the reduced costs.  <a href="#af027cee8179a876a4879c73820c380d1">More...</a><br /></td></tr>
<tr class="separator:af027cee8179a876a4879c73820c380d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c103b582c910ccfda354032aae5722e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a7c103b582c910ccfda354032aae5722e">MCFGetRC</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> i)=0</td></tr>
<tr class="memdesc:a7c103b582c910ccfda354032aae5722e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reduced cost of the i-th arc.  <a href="#a7c103b582c910ccfda354032aae5722e">More...</a><br /></td></tr>
<tr class="separator:a7c103b582c910ccfda354032aae5722e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading the objective function value</div></td></tr>
<tr class="memitem:a109d7c021feda837d8ca5051fc24b6ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a109d7c021feda837d8ca5051fc24b6ea">MCFGetFO</a> (void)=0</td></tr>
<tr class="memdesc:a109d7c021feda837d8ca5051fc24b6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the objective function value of the primal solution currently returned by <a class="el" href="classMCFClass.html#a4eb307e0707adaef99bb0e08c9e10eb8" title="Return a read-only pointer to an internal data structure containing the flow solution in &quot;dense&quot; form...">MCFGetX()</a>.  <a href="#a109d7c021feda837d8ca5051fc24b6ea">More...</a><br /></td></tr>
<tr class="separator:a109d7c021feda837d8ca5051fc24b6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca66f278ea62640af8e54590c687d715"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aca66f278ea62640af8e54590c687d715">MCFGetDFO</a> (void)</td></tr>
<tr class="memdesc:aca66f278ea62640af8e54590c687d715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the objective function value of the dual solution currently returned by <a class="el" href="classMCFClass.html#a8f1a95d5c707f83ffc6aecba1e7e0e10" title="Return a read-only pointer to an internal data structure containing the node potentials. ">MCFGetPi()</a> / <a class="el" href="classMCFClass.html#af027cee8179a876a4879c73820c380d1" title="Return a read-only pointer to an internal data structure containing the reduced costs. ">MCFGetRC()</a>.  <a href="#aca66f278ea62640af8e54590c687d715">More...</a><br /></td></tr>
<tr class="separator:aca66f278ea62640af8e54590c687d715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getting unfeasibility certificate</div></td></tr>
<tr class="memitem:a30483c3e5699b77f528c2e6f33c80ece"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a30483c3e5699b77f528c2e6f33c80ece">MCFGetUnfCut</a> (<a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Cut)</td></tr>
<tr class="memdesc:a30483c3e5699b77f528c2e6f33c80ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unfeasibility certificate.  <a href="#a30483c3e5699b77f528c2e6f33c80ece">More...</a><br /></td></tr>
<tr class="separator:a30483c3e5699b77f528c2e6f33c80ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getting unboundedness certificate</div></td></tr>
<tr class="memitem:a88fa193007f0bc6ef751664a9f4c75a2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a88fa193007f0bc6ef751664a9f4c75a2">MCFGetUnbCycl</a> (<a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Pred, <a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> ArcPred)</td></tr>
<tr class="memdesc:a88fa193007f0bc6ef751664a9f4c75a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unboundedness certificate.  <a href="#a88fa193007f0bc6ef751664a9f4c75a2">More...</a><br /></td></tr>
<tr class="separator:a88fa193007f0bc6ef751664a9f4c75a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Saving/restoring the state of the solver</div></td></tr>
<tr class="memitem:a995a05ecaa6ece4be3afbddbb36b2c4e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a995a05ecaa6ece4be3afbddbb36b2c4e">MCFGetState</a> (void)</td></tr>
<tr class="memdesc:a995a05ecaa6ece4be3afbddbb36b2c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the state of the MCF solver.  <a href="#a995a05ecaa6ece4be3afbddbb36b2c4e">More...</a><br /></td></tr>
<tr class="separator:a995a05ecaa6ece4be3afbddbb36b2c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14589cd80aed231b6fc7da247f50601"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac14589cd80aed231b6fc7da247f50601">MCFPutState</a> (<a class="el" href="classMCFClass.html#ab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a> S)</td></tr>
<tr class="memdesc:ac14589cd80aed231b6fc7da247f50601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the solver to the state in which it was when the state &lsquo;S&rsquo; was created with <a class="el" href="classMCFClass.html#a995a05ecaa6ece4be3afbddbb36b2c4e" title="Save the state of the MCF solver. ">MCFGetState()</a> [see above].  <a href="#ac14589cd80aed231b6fc7da247f50601">More...</a><br /></td></tr>
<tr class="separator:ac14589cd80aed231b6fc7da247f50601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Time the code</div></td></tr>
<tr class="memitem:a779a8829874de569dc0e09f40b6cd569"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a779a8829874de569dc0e09f40b6cd569">TimeMCF</a> (double &amp;t_us, double &amp;t_ss)</td></tr>
<tr class="memdesc:a779a8829874de569dc0e09f40b6cd569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time the code.  <a href="#a779a8829874de569dc0e09f40b6cd569">More...</a><br /></td></tr>
<tr class="separator:a779a8829874de569dc0e09f40b6cd569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ce05b3fabc8d4f80332a02bce2a623"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a25ce05b3fabc8d4f80332a02bce2a623">TimeMCF</a> (void)</td></tr>
<tr class="memdesc:a25ce05b3fabc8d4f80332a02bce2a623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like TimeMCF(double,double) [see above], but returns the total time.  <a href="#a25ce05b3fabc8d4f80332a02bce2a623">More...</a><br /></td></tr>
<tr class="separator:a25ce05b3fabc8d4f80332a02bce2a623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Check the solutions</div></td></tr>
<tr class="memitem:a41b70e84f98f30b408d0ffb191ff4442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a41b70e84f98f30b408d0ffb191ff4442">CheckPSol</a> (void)</td></tr>
<tr class="memdesc:a41b70e84f98f30b408d0ffb191ff4442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the primal solution returned by the solver is primal feasible.  <a href="#a41b70e84f98f30b408d0ffb191ff4442">More...</a><br /></td></tr>
<tr class="separator:a41b70e84f98f30b408d0ffb191ff4442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bd6bc3b87534b4a67d0d93abedbd93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a81bd6bc3b87534b4a67d0d93abedbd93">CheckDSol</a> (void)</td></tr>
<tr class="memdesc:a81bd6bc3b87534b4a67d0d93abedbd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the dual solution returned by the solver is dual feasible.  <a href="#a81bd6bc3b87534b4a67d0d93abedbd93">More...</a><br /></td></tr>
<tr class="separator:a81bd6bc3b87534b4a67d0d93abedbd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading graph size</div></td></tr>
<tr class="memitem:acfb1bca6eb363c912c45c587f4bc214b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#acfb1bca6eb363c912c45c587f4bc214b">MCFnmax</a> (void)</td></tr>
<tr class="memdesc:acfb1bca6eb363c912c45c587f4bc214b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of nodes for this instance of <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a>.  <a href="#acfb1bca6eb363c912c45c587f4bc214b">More...</a><br /></td></tr>
<tr class="separator:acfb1bca6eb363c912c45c587f4bc214b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63cff04d49de9f84b9ddc8585334690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af63cff04d49de9f84b9ddc8585334690">MCFmmax</a> (void)</td></tr>
<tr class="memdesc:af63cff04d49de9f84b9ddc8585334690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of arcs for this instance of <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a>.  <a href="#af63cff04d49de9f84b9ddc8585334690">More...</a><br /></td></tr>
<tr class="separator:af63cff04d49de9f84b9ddc8585334690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6438187f454e795c03a850bfab31be84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a6438187f454e795c03a850bfab31be84">MCFn</a> (void)</td></tr>
<tr class="memdesc:a6438187f454e795c03a850bfab31be84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the current graph.  <a href="#a6438187f454e795c03a850bfab31be84">More...</a><br /></td></tr>
<tr class="separator:a6438187f454e795c03a850bfab31be84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d5a0d0fc49882de0b4eb3146f1b7a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab4d5a0d0fc49882de0b4eb3146f1b7a6">MCFm</a> (void)</td></tr>
<tr class="memdesc:ab4d5a0d0fc49882de0b4eb3146f1b7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of arcs in the current graph.  <a href="#ab4d5a0d0fc49882de0b4eb3146f1b7a6">More...</a><br /></td></tr>
<tr class="separator:ab4d5a0d0fc49882de0b4eb3146f1b7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading graph topology</div></td></tr>
<tr class="memitem:aa2314bf81483649dd1cb9dada0de6832"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aa2314bf81483649dd1cb9dada0de6832">MCFArcs</a> (<a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Startv, <a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Endv, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:aa2314bf81483649dd1cb9dada0de6832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the starting (tail) and ending (head) nodes of the arcs in Startv[] and Endv[].  <a href="#aa2314bf81483649dd1cb9dada0de6832">More...</a><br /></td></tr>
<tr class="separator:aa2314bf81483649dd1cb9dada0de6832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f1b21bfe422e2d54de0dc56231599b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae3f1b21bfe422e2d54de0dc56231599b">MCFSNde</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> i)=0</td></tr>
<tr class="memdesc:ae3f1b21bfe422e2d54de0dc56231599b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the starting (tail) node of the arc &lsquo;i&rsquo;.  <a href="#ae3f1b21bfe422e2d54de0dc56231599b">More...</a><br /></td></tr>
<tr class="separator:ae3f1b21bfe422e2d54de0dc56231599b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0d5b8f2dfd729783e7c0fd604dc896"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a1b0d5b8f2dfd729783e7c0fd604dc896">MCFENde</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> i)=0</td></tr>
<tr class="memdesc:a1b0d5b8f2dfd729783e7c0fd604dc896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ending (head) node of the arc &lsquo;i&rsquo;.  <a href="#a1b0d5b8f2dfd729783e7c0fd604dc896">More...</a><br /></td></tr>
<tr class="separator:a1b0d5b8f2dfd729783e7c0fd604dc896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aeea0e6fd59fc54c2d7a0d21099ea21"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a3aeea0e6fd59fc54c2d7a0d21099ea21">MCFSNdes</a> (void)</td></tr>
<tr class="memdesc:a3aeea0e6fd59fc54c2d7a0d21099ea21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal vector containing the starting (tail) nodes for each arc.  <a href="#a3aeea0e6fd59fc54c2d7a0d21099ea21">More...</a><br /></td></tr>
<tr class="separator:a3aeea0e6fd59fc54c2d7a0d21099ea21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5494247213fd86574798bba97a2eb604"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a5494247213fd86574798bba97a2eb604">MCFENdes</a> (void)</td></tr>
<tr class="memdesc:a5494247213fd86574798bba97a2eb604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal vector containing the ending (head) nodes for each arc.  <a href="#a5494247213fd86574798bba97a2eb604">More...</a><br /></td></tr>
<tr class="separator:a5494247213fd86574798bba97a2eb604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading arc costs</div></td></tr>
<tr class="memitem:ab6dbac4cde9477589de653081986abb4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab6dbac4cde9477589de653081986abb4">MCFCosts</a> (<a class="el" href="classMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> Costv, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:ab6dbac4cde9477589de653081986abb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the arc costs into Costv[].  <a href="#ab6dbac4cde9477589de653081986abb4">More...</a><br /></td></tr>
<tr class="separator:ab6dbac4cde9477589de653081986abb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac666df7c1e7ed07c0f7574ec307c9e82"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac666df7c1e7ed07c0f7574ec307c9e82">MCFCost</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> i)=0</td></tr>
<tr class="memdesc:ac666df7c1e7ed07c0f7574ec307c9e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cost of the i-th arc.  <a href="#ac666df7c1e7ed07c0f7574ec307c9e82">More...</a><br /></td></tr>
<tr class="separator:ac666df7c1e7ed07c0f7574ec307c9e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dcdf78883ef28452a4698aaa6bf14b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a75dcdf78883ef28452a4698aaa6bf14b">MCFCosts</a> (void)</td></tr>
<tr class="memdesc:a75dcdf78883ef28452a4698aaa6bf14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal vector containing the arc costs.  <a href="#a75dcdf78883ef28452a4698aaa6bf14b">More...</a><br /></td></tr>
<tr class="separator:a75dcdf78883ef28452a4698aaa6bf14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd08873d1e15db41bf42648226f8feb1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#acd08873d1e15db41bf42648226f8feb1">MCFQCoef</a> (<a class="el" href="classMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> Qv, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:acd08873d1e15db41bf42648226f8feb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9227949082669e0e9ca0c545406f1f4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab9227949082669e0e9ca0c545406f1f4">MCFQCoef</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> i)</td></tr>
<tr class="separator:ab9227949082669e0e9ca0c545406f1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea78552d525e5ce61f3e3887774cc11"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aeea78552d525e5ce61f3e3887774cc11">MCFQCoef</a> (void)</td></tr>
<tr class="memdesc:aeea78552d525e5ce61f3e3887774cc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal vector containing the arc costs.  <a href="#aeea78552d525e5ce61f3e3887774cc11">More...</a><br /></td></tr>
<tr class="separator:aeea78552d525e5ce61f3e3887774cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading arc capacities</div></td></tr>
<tr class="memitem:a999b9738aa5cb925c5b4a799ed6d4838"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a999b9738aa5cb925c5b4a799ed6d4838">MCFUCaps</a> (<a class="el" href="classMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> UCapv, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a999b9738aa5cb925c5b4a799ed6d4838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the arc capacities into UCapv[].  <a href="#a999b9738aa5cb925c5b4a799ed6d4838">More...</a><br /></td></tr>
<tr class="separator:a999b9738aa5cb925c5b4a799ed6d4838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af18f0859dd6ddea9d29ed39c9b27a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a3af18f0859dd6ddea9d29ed39c9b27a3">MCFUCap</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> i)=0</td></tr>
<tr class="memdesc:a3af18f0859dd6ddea9d29ed39c9b27a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the capacity of the i-th arc.  <a href="#a3af18f0859dd6ddea9d29ed39c9b27a3">More...</a><br /></td></tr>
<tr class="separator:a3af18f0859dd6ddea9d29ed39c9b27a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae54f2f08242d5fd631eb613d82e4d1c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aae54f2f08242d5fd631eb613d82e4d1c">MCFUCaps</a> (void)</td></tr>
<tr class="memdesc:aae54f2f08242d5fd631eb613d82e4d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal vector containing the arc capacities.  <a href="#aae54f2f08242d5fd631eb613d82e4d1c">More...</a><br /></td></tr>
<tr class="separator:aae54f2f08242d5fd631eb613d82e4d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading node deficits</div></td></tr>
<tr class="memitem:a99e2d376efc0d9552a62f9b71512b563"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a99e2d376efc0d9552a62f9b71512b563">MCFDfcts</a> (<a class="el" href="classMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> Dfctv, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a99e2d376efc0d9552a62f9b71512b563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the node deficits into Dfctv[].  <a href="#a99e2d376efc0d9552a62f9b71512b563">More...</a><br /></td></tr>
<tr class="separator:a99e2d376efc0d9552a62f9b71512b563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e07cb46404db5a9fd83075a0908208"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a81e07cb46404db5a9fd83075a0908208">MCFDfct</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> i)=0</td></tr>
<tr class="memdesc:a81e07cb46404db5a9fd83075a0908208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the deficit of the i-th node.  <a href="#a81e07cb46404db5a9fd83075a0908208">More...</a><br /></td></tr>
<tr class="separator:a81e07cb46404db5a9fd83075a0908208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e8d115e0f2bd90e1b65a573cb46ae4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ad7e8d115e0f2bd90e1b65a573cb46ae4">MCFDfcts</a> (void)</td></tr>
<tr class="memdesc:ad7e8d115e0f2bd90e1b65a573cb46ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal vector containing the node deficits.  <a href="#ad7e8d115e0f2bd90e1b65a573cb46ae4">More...</a><br /></td></tr>
<tr class="separator:ad7e8d115e0f2bd90e1b65a573cb46ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Write problem to file</div></td></tr>
<tr class="memitem:acd008d9548bf3e1aef1291864171bb2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#acd008d9548bf3e1aef1291864171bb2d">WriteMCF</a> (ostream &amp;oStrm, int frmt=0)</td></tr>
<tr class="memdesc:acd008d9548bf3e1aef1291864171bb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the current MCF problem to an ostream.  <a href="#acd008d9548bf3e1aef1291864171bb2d">More...</a><br /></td></tr>
<tr class="separator:acd008d9548bf3e1aef1291864171bb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Changing the costs</div></td></tr>
<tr class="memitem:aedaaa3c7820183c210ff8b1cc716c27d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aedaaa3c7820183c210ff8b1cc716c27d">ChgCosts</a> (<a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> NCost, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:aedaaa3c7820183c210ff8b1cc716c27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the arc costs.  <a href="#aedaaa3c7820183c210ff8b1cc716c27d">More...</a><br /></td></tr>
<tr class="separator:aedaaa3c7820183c210ff8b1cc716c27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ab6d76a454b3f792665cce35a250f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a41ab6d76a454b3f792665cce35a250f3">ChgCost</a> (<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> arc, <a class="el" href="classMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a> NCost)=0</td></tr>
<tr class="memdesc:a41ab6d76a454b3f792665cce35a250f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the cost of the i-th arc.  <a href="#a41ab6d76a454b3f792665cce35a250f3">More...</a><br /></td></tr>
<tr class="separator:a41ab6d76a454b3f792665cce35a250f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa1d49c3edafbf4783d579d175070fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4aa1d49c3edafbf4783d579d175070fd">ChgQCoef</a> (<a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> NQCoef=0, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:a4aa1d49c3edafbf4783d579d175070fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df44e18d436b2500e5608d6ab2d58ad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4df44e18d436b2500e5608d6ab2d58ad">ChgQCoef</a> (<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> arc, <a class="el" href="classMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a> NQCoef)</td></tr>
<tr class="separator:a4df44e18d436b2500e5608d6ab2d58ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Changing the capacities</div></td></tr>
<tr class="memitem:ad548db90d9914f8a40bbb4823f274ccc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ad548db90d9914f8a40bbb4823f274ccc">ChgUCaps</a> (<a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> NCap, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:ad548db90d9914f8a40bbb4823f274ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the arc capacities.  <a href="#ad548db90d9914f8a40bbb4823f274ccc">More...</a><br /></td></tr>
<tr class="separator:ad548db90d9914f8a40bbb4823f274ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832883594b6ea5a00fabc9f4be41d9e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a832883594b6ea5a00fabc9f4be41d9e5">ChgUCap</a> (<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> arc, <a class="el" href="classMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> NCap)=0</td></tr>
<tr class="memdesc:a832883594b6ea5a00fabc9f4be41d9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the capacity of the i-th arc.  <a href="#a832883594b6ea5a00fabc9f4be41d9e5">More...</a><br /></td></tr>
<tr class="separator:a832883594b6ea5a00fabc9f4be41d9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Changing the deficits</div></td></tr>
<tr class="memitem:a50ee5aaf0f8b39a1edec078828ade458"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a50ee5aaf0f8b39a1edec078828ade458">ChgDfcts</a> (<a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> NDfct, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a50ee5aaf0f8b39a1edec078828ade458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the node deficits.  <a href="#a50ee5aaf0f8b39a1edec078828ade458">More...</a><br /></td></tr>
<tr class="separator:a50ee5aaf0f8b39a1edec078828ade458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae235c4b587c8cffb777719c9221970"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a5ae235c4b587c8cffb777719c9221970">ChgDfct</a> (<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> node, <a class="el" href="classMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> NDfct)=0</td></tr>
<tr class="memdesc:a5ae235c4b587c8cffb777719c9221970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the deficit of the i-th node.  <a href="#a5ae235c4b587c8cffb777719c9221970">More...</a><br /></td></tr>
<tr class="separator:a5ae235c4b587c8cffb777719c9221970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Changing graph topology</div></td></tr>
<tr class="memitem:ae1c33ba491b57343fbc157123fff5b11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae1c33ba491b57343fbc157123fff5b11">CloseArc</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> name)=0</td></tr>
<tr class="memdesc:ae1c33ba491b57343fbc157123fff5b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Close" the arc &lsquo;name&rsquo;.  <a href="#ae1c33ba491b57343fbc157123fff5b11">More...</a><br /></td></tr>
<tr class="separator:ae1c33ba491b57343fbc157123fff5b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db08ae33bcdb997677a69f36c60c1e5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a2db08ae33bcdb997677a69f36c60c1e5">IsClosedArc</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> name)=0</td></tr>
<tr class="memdesc:a2db08ae33bcdb997677a69f36c60c1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMCFClass.html#a2db08ae33bcdb997677a69f36c60c1e5" title="IsClosedArc() returns true if and only if the arc name is closed. ">IsClosedArc()</a> returns true if and only if the arc &lsquo;name&rsquo; is closed.  <a href="#a2db08ae33bcdb997677a69f36c60c1e5">More...</a><br /></td></tr>
<tr class="separator:a2db08ae33bcdb997677a69f36c60c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecb8b32d512eea7daafba0e06ab4742"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#abecb8b32d512eea7daafba0e06ab4742">DelNode</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> name)=0</td></tr>
<tr class="memdesc:abecb8b32d512eea7daafba0e06ab4742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the node &lsquo;name&rsquo;.  <a href="#abecb8b32d512eea7daafba0e06ab4742">More...</a><br /></td></tr>
<tr class="separator:abecb8b32d512eea7daafba0e06ab4742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab902a23d1c9520a22b79de5d451c3348"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab902a23d1c9520a22b79de5d451c3348">OpenArc</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> name)=0</td></tr>
<tr class="memdesc:ab902a23d1c9520a22b79de5d451c3348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the previously closed arc &lsquo;name&rsquo;.  <a href="#ab902a23d1c9520a22b79de5d451c3348">More...</a><br /></td></tr>
<tr class="separator:ab902a23d1c9520a22b79de5d451c3348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d58679267d8b620cc3337583dab4626"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a6d58679267d8b620cc3337583dab4626">AddNode</a> (<a class="el" href="classMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> aDfct)=0</td></tr>
<tr class="memdesc:a6d58679267d8b620cc3337583dab4626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new node with deficit aDfct, returning its name.  <a href="#a6d58679267d8b620cc3337583dab4626">More...</a><br /></td></tr>
<tr class="separator:a6d58679267d8b620cc3337583dab4626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2d28b0b0a2420d6b8b7093d827fa67"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aef2d28b0b0a2420d6b8b7093d827fa67">ChangeArc</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> name, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> nSN=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;(), <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> nEN=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:aef2d28b0b0a2420d6b8b7093d827fa67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the starting and/or ending node of arc &lsquo;name&rsquo; to nSN and nEN.  <a href="#aef2d28b0b0a2420d6b8b7093d827fa67">More...</a><br /></td></tr>
<tr class="separator:aef2d28b0b0a2420d6b8b7093d827fa67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae291d6625ff31a5fdcc1ef166e2dee34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae291d6625ff31a5fdcc1ef166e2dee34">DelArc</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> name)=0</td></tr>
<tr class="memdesc:ae291d6625ff31a5fdcc1ef166e2dee34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the arc &lsquo;name&rsquo;.  <a href="#ae291d6625ff31a5fdcc1ef166e2dee34">More...</a><br /></td></tr>
<tr class="separator:ae291d6625ff31a5fdcc1ef166e2dee34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f72b1b728182519a6a11accdfa78c7d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a5f72b1b728182519a6a11accdfa78c7d">IsDeletedArc</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> name)=0</td></tr>
<tr class="memdesc:a5f72b1b728182519a6a11accdfa78c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if and only if the arc &lsquo;name&rsquo; is deleted.  <a href="#a5f72b1b728182519a6a11accdfa78c7d">More...</a><br /></td></tr>
<tr class="separator:a5f72b1b728182519a6a11accdfa78c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564d624f62ccc0c130d733cc5470cb6d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a564d624f62ccc0c130d733cc5470cb6d">AddArc</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> Start, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> End, <a class="el" href="classMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> aU, <a class="el" href="classMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a> aC)=0</td></tr>
<tr class="memdesc:a564d624f62ccc0c130d733cc5470cb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the new arc ( Start , End ) with cost aC and capacity aU, returning its name.  <a href="#a564d624f62ccc0c130d733cc5470cb6d">More...</a><br /></td></tr>
<tr class="separator:a564d624f62ccc0c130d733cc5470cb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a93c0882740d38b9f8eb05994a01f76b7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a93c0882740d38b9f8eb05994a01f76b7">~MCFClass</a> ()</td></tr>
<tr class="memdesc:a93c0882740d38b9f8eb05994a01f76b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class.  <a href="#a93c0882740d38b9f8eb05994a01f76b7">More...</a><br /></td></tr>
<tr class="separator:a93c0882740d38b9f8eb05994a01f76b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Managing comparisons.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The following methods are provided for making it easier to perform comparisons, with and without tolerances. </p>
</div></td></tr>
<tr class="memitem:aadaea79b7a516a86d9e318c31ce3d489"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aadaea79b7a516a86d9e318c31ce3d489"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aadaea79b7a516a86d9e318c31ce3d489">ETZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:aadaea79b7a516a86d9e318c31ce3d489"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is equal to zero (possibly considering tolerances).  <a href="#aadaea79b7a516a86d9e318c31ce3d489">More...</a><br /></td></tr>
<tr class="separator:aadaea79b7a516a86d9e318c31ce3d489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af314a8df7e38143854b9bf17c8eb25fc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af314a8df7e38143854b9bf17c8eb25fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af314a8df7e38143854b9bf17c8eb25fc">GTZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:af314a8df7e38143854b9bf17c8eb25fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is greater than zero (possibly considering tolerances).  <a href="#af314a8df7e38143854b9bf17c8eb25fc">More...</a><br /></td></tr>
<tr class="separator:af314a8df7e38143854b9bf17c8eb25fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae414baaa6f224ce576574baa1e71650a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae414baaa6f224ce576574baa1e71650a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae414baaa6f224ce576574baa1e71650a">GEZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:ae414baaa6f224ce576574baa1e71650a"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is greater than or equal to zero (possibly considering tolerances).  <a href="#ae414baaa6f224ce576574baa1e71650a">More...</a><br /></td></tr>
<tr class="separator:ae414baaa6f224ce576574baa1e71650a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab355a057db64a4b3da5209f747c01eae"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab355a057db64a4b3da5209f747c01eae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab355a057db64a4b3da5209f747c01eae">LTZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:ab355a057db64a4b3da5209f747c01eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is less than zero (possibly considering tolerances).  <a href="#ab355a057db64a4b3da5209f747c01eae">More...</a><br /></td></tr>
<tr class="separator:ab355a057db64a4b3da5209f747c01eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1dfab25fba0d9badd0cce4dc99933b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adc1dfab25fba0d9badd0cce4dc99933b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#adc1dfab25fba0d9badd0cce4dc99933b">LEZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:adc1dfab25fba0d9badd0cce4dc99933b"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is less than or equal to zero (possibly considering tolerances).  <a href="#adc1dfab25fba0d9badd0cce4dc99933b">More...</a><br /></td></tr>
<tr class="separator:adc1dfab25fba0d9badd0cce4dc99933b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945c3a54be501ad68f71adaf7771d457"><td class="memTemplParams" colspan="2"><a id="a945c3a54be501ad68f71adaf7771d457"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a945c3a54be501ad68f71adaf7771d457"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a945c3a54be501ad68f71adaf7771d457">GT</a> (T x, T y, const T eps)</td></tr>
<tr class="memdesc:a945c3a54be501ad68f71adaf7771d457"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is greater than flow y (possibly considering tolerances). <br /></td></tr>
<tr class="separator:a945c3a54be501ad68f71adaf7771d457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0374fafa5efdfe1d78c22efaa9f9d6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7c0374fafa5efdfe1d78c22efaa9f9d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a7c0374fafa5efdfe1d78c22efaa9f9d6">LT</a> (T x, T y, const T eps)</td></tr>
<tr class="memdesc:a7c0374fafa5efdfe1d78c22efaa9f9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is less than flow y (possibly considering tolerances).  <a href="#a7c0374fafa5efdfe1d78c22efaa9f9d6">More...</a><br /></td></tr>
<tr class="separator:a7c0374fafa5efdfe1d78c22efaa9f9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7f0f8bcc88c30609d766a4e723a53dac"><td class="memItemLeft" align="right" valign="top"><a id="a7f0f8bcc88c30609d766a4e723a53dac"></a>
<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a7f0f8bcc88c30609d766a4e723a53dac">n</a></td></tr>
<tr class="memdesc:a7f0f8bcc88c30609d766a4e723a53dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of nodes <br /></td></tr>
<tr class="separator:a7f0f8bcc88c30609d766a4e723a53dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02366e13d56b1124db9bf8281b73ca9a"><td class="memItemLeft" align="right" valign="top"><a id="a02366e13d56b1124db9bf8281b73ca9a"></a>
<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a02366e13d56b1124db9bf8281b73ca9a">nmax</a></td></tr>
<tr class="memdesc:a02366e13d56b1124db9bf8281b73ca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of nodes <br /></td></tr>
<tr class="separator:a02366e13d56b1124db9bf8281b73ca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d50257929003fb000e6bcc1db02fd6"><td class="memItemLeft" align="right" valign="top"><a id="a61d50257929003fb000e6bcc1db02fd6"></a>
<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a61d50257929003fb000e6bcc1db02fd6">m</a></td></tr>
<tr class="memdesc:a61d50257929003fb000e6bcc1db02fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of arcs <br /></td></tr>
<tr class="separator:a61d50257929003fb000e6bcc1db02fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e7022437bc38dc11cffe32d4b2332c"><td class="memItemLeft" align="right" valign="top"><a id="a93e7022437bc38dc11cffe32d4b2332c"></a>
<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a93e7022437bc38dc11cffe32d4b2332c">mmax</a></td></tr>
<tr class="memdesc:a93e7022437bc38dc11cffe32d4b2332c"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of arcs <br /></td></tr>
<tr class="separator:a93e7022437bc38dc11cffe32d4b2332c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e27f49150e9a14580fb313cc2777e00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a6e27f49150e9a14580fb313cc2777e00">status</a></td></tr>
<tr class="memdesc:a6e27f49150e9a14580fb313cc2777e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">return status, see the comments to <a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be" title="Returns an int describing the current status of the MCF solver. ">MCFGetStatus()</a> above.  <a href="#a6e27f49150e9a14580fb313cc2777e00">More...</a><br /></td></tr>
<tr class="separator:a6e27f49150e9a14580fb313cc2777e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b691e0b125c33ab526888ab754e461"><td class="memItemLeft" align="right" valign="top"><a id="a89b691e0b125c33ab526888ab754e461"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a89b691e0b125c33ab526888ab754e461">Senstv</a></td></tr>
<tr class="memdesc:a89b691e0b125c33ab526888ab754e461"><td class="mdescLeft">&#160;</td><td class="mdescRight">true &lt;=&gt; the latest optimal solution should be exploited <br /></td></tr>
<tr class="separator:a89b691e0b125c33ab526888ab754e461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7624a057d988dd8f61b038ff459cd0b"><td class="memItemLeft" align="right" valign="top"><a id="ab7624a057d988dd8f61b038ff459cd0b"></a>
OPTtimers *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab7624a057d988dd8f61b038ff459cd0b">MCFt</a></td></tr>
<tr class="memdesc:ab7624a057d988dd8f61b038ff459cd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">timer for performances evaluation <br /></td></tr>
<tr class="separator:ab7624a057d988dd8f61b038ff459cd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b1c456efbc2e544b82cb6553f6df8d"><td class="memItemLeft" align="right" valign="top"><a id="a65b1c456efbc2e544b82cb6553f6df8d"></a>
<a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a65b1c456efbc2e544b82cb6553f6df8d">EpsFlw</a></td></tr>
<tr class="memdesc:a65b1c456efbc2e544b82cb6553f6df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision for comparing arc flows / capacities <br /></td></tr>
<tr class="separator:a65b1c456efbc2e544b82cb6553f6df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9159ee7ca50477fd57f6854ff73b2874"><td class="memItemLeft" align="right" valign="top"><a id="a9159ee7ca50477fd57f6854ff73b2874"></a>
<a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a9159ee7ca50477fd57f6854ff73b2874">EpsDfct</a></td></tr>
<tr class="memdesc:a9159ee7ca50477fd57f6854ff73b2874"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision for comparing node deficits <br /></td></tr>
<tr class="separator:a9159ee7ca50477fd57f6854ff73b2874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8c11b8ba9065dd3bc0f7b5ec423869"><td class="memItemLeft" align="right" valign="top"><a id="aad8c11b8ba9065dd3bc0f7b5ec423869"></a>
<a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aad8c11b8ba9065dd3bc0f7b5ec423869">EpsCst</a></td></tr>
<tr class="memdesc:aad8c11b8ba9065dd3bc0f7b5ec423869"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision for comparing arc costs <br /></td></tr>
<tr class="separator:aad8c11b8ba9065dd3bc0f7b5ec423869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bad127f3e412819d99baff0c51e5be8"><td class="memItemLeft" align="right" valign="top"><a id="a8bad127f3e412819d99baff0c51e5be8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a8bad127f3e412819d99baff0c51e5be8">MaxTime</a></td></tr>
<tr class="memdesc:a8bad127f3e412819d99baff0c51e5be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">max time (in seconds) in which MCF Solver can find an optimal solution (0 = no limits) <br /></td></tr>
<tr class="separator:a8bad127f3e412819d99baff0c51e5be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259eaddd4d91ec0a7d00ff6db0a3f40a"><td class="memItemLeft" align="right" valign="top"><a id="a259eaddd4d91ec0a7d00ff6db0a3f40a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a259eaddd4d91ec0a7d00ff6db0a3f40a">MaxIter</a></td></tr>
<tr class="memdesc:a259eaddd4d91ec0a7d00ff6db0a3f40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">max number of iterations in which MCF Solver can find an optimal solution (0 = no limits) <br /></td></tr>
<tr class="separator:a259eaddd4d91ec0a7d00ff6db0a3f40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This abstract base class defines a standard interface for (linear or convex quadartic separable) Min Cost Flow (MCF) problem solvers. </p>
<p>The data of the problem consist of a (directed) graph G = ( N , A ) with n = |N| nodes and m = |A| (directed) arcs. Each node &lsquo;i&rsquo; has a deficit b[ i ], i.e., the amount of flow that is produced/consumed by the node: source nodes (which produce flow) have negative deficits and sink nodes (which consume flow) have positive deficits. Each arc &lsquo;(i, j)&rsquo; has an upper capacity U[ i , j ], a linear cost coefficient C[ i , j ] and a (non negative) quadratic cost coefficient Q[ i , j ]. Flow variables X[ i , j ] represents the amount of flow to be sent on arc (i, j). Parallel arcs, i.e., multiple copies of the same arc &lsquo;(i, j)&rsquo; (with possibily different costs and/or capacities) are in general allowed. The formulation of the problem is therefore: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \min \sum_{ (i, j) \in A } C[ i , j ] X[ i, j ] + Q[ i , j ] X[ i, j ]^2 / 2 \]" src="form_1.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ (1) \sum_{ (j, i) \in A } X[ j , i ] - \sum_{ (i, j) \in A } X[ i , j ] = b[ i ] \hspace{1cm} i \in N \]" src="form_2.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ (2) 0 \leq X[ i , j ] \leq U[ i , j ] \hspace{1cm} (i, j) \in A \]" src="form_3.png"/>
</p>
<p> The n equations (1) are the flow conservation constraints and the 2m inequalities (2) are the flow nonnegativity and capacity constraints. At least one of the flow conservation constraints is redundant, as the demands must be balanced ( <img class="formulaInl" alt="$\sum_{ i \in N } b[ i ] = 0$" src="form_4.png"/>); indeed, exactly n - ConnectedComponents( G ) flow conservation constraints are redundant, as demands must be balanced in each connected component of G. Let us denote by QA and LA the disjoint subsets of A containing, respectively, "quadratic" arcs (with Q[ i , j ] &gt; 0) and "linear" arcs (with Q[ i , j ] = 0); the (MCF) problem is linear if QA is empty, and nonlinear (convex quadratic) if QA is nonempty.</p>
<p>The dual of the problem is: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \max \sum_{ i \in N } Pi[ i ] b[ i ] - \sum_{ (i, j) \in A } W[ i , j ] U[ i , j ] - \sum_{ (i, j) \in AQ } V[ i , j ]^2 / ( 2 * Q[ i , j ] ) \]" src="form_5.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ (3.a) C[ i , j ] - Pi[ j ] + Pi[ i ] + W[ i , j ] - Z[ i , j ] = 0 \hspace{1cm} (i, j) \in AL \]" src="form_6.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ (3.b) C[ i , j ] - Pi[ j ] + Pi[ i ] + W[ i , j ] - Z[ i , j ] = V[ i , j ] \hspace{1cm} (i, j) \in AQ \]" src="form_7.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ (4.a) W[ i , j ] \geq 0 \hspace{1cm} (i, j) \in A \]" src="form_8.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ (4.b) Z[ i , j ] \geq 0 \hspace{1cm} (i, j) \in A \]" src="form_9.png"/>
</p>
<p>Pi[] is said the vector of node potentials for the problem, W[] are bound variables and Z[] are slack variables. Given Pi[], the quantities </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ RC[ i , j ] = C[ i , j ] + Q[ i , j ] * X[ i , j ] - Pi[ j ] + Pi[ i ] \]" src="form_10.png"/>
</p>
<p> are said the "reduced costs" of arcs.</p>
<p>A primal and dual feasible solution pair is optimal if and only if the complementary slackness conditions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ RC[ i , j ] &gt; 0 \Rightarrow X[ i , j ] = 0 \]" src="form_11.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ RC[ i , j ] &lt; 0 \Rightarrow X[ i , j ] = U[ i , j ] \]" src="form_12.png"/>
</p>
<p> are satisfied for all arcs (i, j) of A.</p>
<p>The <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> class provides an interface with methods for managing and solving problems of this kind. Actually, the class can also be used as an interface for more general NonLinear MCF problems, where the cost function either nonseparable ( C( X ) ) or arc-separable ( <img class="formulaInl" alt="$\sum_{ (i, j) \in A } C_{i,j}( X[ i, j ] )$" src="form_13.png"/> ). However, solvers for NonLinear MCF problems are typically objective-function-specific, and there is no standard way for inputting a nonlinear function different from a separable convex quadratic one, so only the simplest form is dealt with in the interface, leaving more complex NonLinear parts to the interface of derived classes. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af6e60cb841150361862d6b895c523e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e60cb841150361862d6b895c523e0a">&#9670;&nbsp;</a></span>MCFParam</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMCFClass.html#af6e60cb841150361862d6b895c523e0a">MCFParam</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible parameters of the MCF solver, to be used with the methods <a class="el" href="classMCFClass.html#ab8e162715d8454f30679c10372db4db8" title="Set integer parameters of the algorithm. ">SetPar()</a> and <a class="el" href="classMCFClass.html#ac66ea95b63fe61ce67e0f8544f200887" title="This method returns one of the integer parameter of the algorithm. ">GetPar()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aab35d3e473676b56fa123d6df3d855aa0"></a>kMaxTime&#160;</td><td class="fielddoc"><p>max time </p>
</td></tr>
<tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aa50d3edcd55bc1dd84d4e1719430f9d20"></a>kMaxIter&#160;</td><td class="fielddoc"><p>max number of iteration </p>
</td></tr>
<tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aa753a94f6a06a5579eb0855479dfbb6b1"></a>kEpsFlw&#160;</td><td class="fielddoc"><p>tolerance for flows </p>
</td></tr>
<tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aa409d9ed5655d184667a5e486e5110c6e"></a>kEpsDfct&#160;</td><td class="fielddoc"><p>tolerance for deficits </p>
</td></tr>
<tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aaf263085cb23be60527c92896891cd12c"></a>kEpsCst&#160;</td><td class="fielddoc"><p>tolerance for costs </p>
</td></tr>
<tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aa7efdbe01bec821f08a391f9542086475"></a>kReopt&#160;</td><td class="fielddoc"><p>whether or not to reoptimize </p>
</td></tr>
<tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aa99ac8339170db67bf9af4a60362ef7e1"></a>kLastParam&#160;</td><td class="fielddoc"><p>dummy parameter: this is used to allow derived classes to "extend" the set of parameters. </p>
</td></tr>
</table>

</div>
</div>
<a id="a15ef269c5dd98eea5274eb03a3feb5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ef269c5dd98eea5274eb03a3feb5fb">&#9670;&nbsp;</a></span>MCFStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fb">MCFStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible status of the MCF solver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1"></a>kUnSolved&#160;</td><td class="fielddoc"><p>no solution available </p>
</td></tr>
<tr><td class="fieldname"><a id="a15ef269c5dd98eea5274eb03a3feb5fba42e6b26684acf67af002df88a9cf997c"></a>kOK&#160;</td><td class="fielddoc"><p>optimal solution found </p>
</td></tr>
<tr><td class="fieldname"><a id="a15ef269c5dd98eea5274eb03a3feb5fba142714524ffdfe9cfebaa1033fd1a18f"></a>kStopped&#160;</td><td class="fielddoc"><p>optimization stopped </p>
</td></tr>
<tr><td class="fieldname"><a id="a15ef269c5dd98eea5274eb03a3feb5fba7db95dc60f32bc33a35f748f639cc6d0"></a>kUnfeasible&#160;</td><td class="fielddoc"><p>problem is unfeasible </p>
</td></tr>
<tr><td class="fieldname"><a id="a15ef269c5dd98eea5274eb03a3feb5fba4b9de95ee3087851acd98262e09f0be8"></a>kUnbounded&#160;</td><td class="fielddoc"><p>problem is unbounded </p>
</td></tr>
<tr><td class="fieldname"><a id="a15ef269c5dd98eea5274eb03a3feb5fbaacb2c04376333850bff6fb1065c0c171"></a>kError&#160;</td><td class="fielddoc"><p>error in the solver </p>
</td></tr>
</table>

</div>
</div>
<a id="ad7b7f4459be059eae1a7d83a8e190c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b7f4459be059eae1a7d83a8e190c28">&#9670;&nbsp;</a></span>MCFAnswer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28">MCFAnswer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible reoptimization status of the MCF solver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad7b7f4459be059eae1a7d83a8e190c28a503f4e9dca6c8c12ea38f9e8c1be0126"></a>kNo&#160;</td><td class="fielddoc"><p>no </p>
</td></tr>
<tr><td class="fieldname"><a id="ad7b7f4459be059eae1a7d83a8e190c28ace5b3b5f2037b0d65d161b53b7c940fe"></a>kYes&#160;</td><td class="fielddoc"><p>yes </p>
</td></tr>
</table>

</div>
</div>
<a id="adb1b139bac65f5f35bdadc7549a819de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1b139bac65f5f35bdadc7549a819de">&#9670;&nbsp;</a></span>MCFFlFrmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMCFClass.html#adb1b139bac65f5f35bdadc7549a819de">MCFFlFrmt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible file formats in <a class="el" href="classMCFClass.html#acd008d9548bf3e1aef1291864171bb2d" title="Write the current MCF problem to an ostream. ">WriteMCF()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adb1b139bac65f5f35bdadc7549a819dea6e65d07cdd719be7d99902bb47920a37"></a>kDimacs&#160;</td><td class="fielddoc"><p>DIMACS file format for MCF. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb1b139bac65f5f35bdadc7549a819deac27a029d7010490d53e1df36b39597e6"></a>kQDimacs&#160;</td><td class="fielddoc"><p>quadratic DIMACS file format for MCF </p>
</td></tr>
<tr><td class="fieldname"><a id="adb1b139bac65f5f35bdadc7549a819dea65125719fd6c68bc3904a45937fcfd85"></a>kMPS&#160;</td><td class="fielddoc"><p>MPS file format for LP. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb1b139bac65f5f35bdadc7549a819dea7efb98d1b3dfca0f601d4df644b418a0"></a>kFWMPS&#160;</td><td class="fielddoc"><p>"Fixed Width" MPS format </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac598fb1a423b3b722414a53c8549953c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac598fb1a423b3b722414a53c8549953c">&#9670;&nbsp;</a></span>MCFClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html">MCFClass</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>nmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>mmx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the class. </p>
<p>nmx and mmx, if provided, are taken to be respectively the maximum number of nodes and arcs in the network. If nonzero values are passed, memory allocation can be anticipated in the constructor, which is sometimes desirable. The maximum values are stored in the protected fields nmax and mmax, and can be changed with <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">LoadNet()</a> [see below]; however, changing them typically requires memory allocation/deallocation, which is sometimes undesirable outside the constructor.</p>
<p>After that an object has been constructed, no problem is loaded; this has to be done with <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">LoadNet()</a> [see below]. Thus, it is an error to invoke any method which requires the presence of a problem (typicall all except those in the initializations part). The base class provides two protected fields n and m for the current number of nodes and arcs, respectively, that are set to 0 in the constructor precisely to indicate that no instance is currently loaded. </p>

</div>
</div>
<a id="a93c0882740d38b9f8eb05994a01f76b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c0882740d38b9f8eb05994a01f76b7">&#9670;&nbsp;</a></span>~MCFClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classMCFClass.html">MCFClass</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor of the class. </p>
<p>The implementation in the base class only deletes the MCFt field. It is virtual, as it should be. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8d82d26f7845eb69081c860e14c3dc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d82d26f7845eb69081c860e14c3dc4c">&#9670;&nbsp;</a></span>LoadNet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LoadNet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>nmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>mmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>pn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>pm</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>pU</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>pC</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>pDfct</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>pSn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>pEn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inputs a new network. </p>
<p>The parameters nmx and mmx are the new max number of nodes and arcs, possibly overriding those set in the constructor [see above], altough at the likely cost of memory allocation and deallocation. Passing nmx == mmx == 0 is intended as a signal to the solver to deallocate everything and wait for new orders; in this case, all the other parameters are ignored.</p>
<p>Otherwise, in principle all the other parameters have to be provided. Actually, some of them may not be needed for special classes of MCF problems (e.g., costs in a MaxFlow problem, or start/end nodes in a problem defined over a graph with fixed topology, such as a complete graph). Also, passing 0 is allowed to set default values.</p>
<p>The meaning of the parameters is the following:</p>
<ul>
<li>pn is the current number of nodes of the network (&lt;= nmax).</li>
<li>pm is the number of arcs of the network (&lt;= mmax).</li>
<li>pU is the m-vector of the arc upper capacities; capacities must be nonnegative, but can in principle be infinite (== F_INF); passing pU == 0 means that all capacities are infinite;</li>
<li>pC is the m-vector of the arc costs; costs must be finite (&lt; C_INF); passing pC == 0 means that all costs must be 0.</li>
<li>pDfct is the n-vector of the node deficits; source nodes have negative deficits and sink nodes have positive deficits; passing pDfct == 0 means that all deficits must be 0 (a circulation problem);</li>
<li>pSn is the m-vector of the arc starting nodes; pSn == 0 is in principle not allowed, unless the topology of the graph is fixed;</li>
<li>pEn is the m-vector of the arc ending nodes; same comments as for pSn.</li>
</ul>
<p>Note that node "names" in the arrays pSn and pEn must go from 1 to pn if the macro USANAME0 [see above] is set to 0, while they must go from 0 to pn - 1 if USANAME0 is set to 1. In both cases, however, the deficit of the first node is read from the first (0-th) position of pDfct, that is if USANAME0 == 0 then the deficit of the node with name &lsquo;i&rsquo; is read from pDfct[ i - 1 ].</p>
<p>The data passed to <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">LoadNet()</a> can be used to specify that the arc &lsquo;i&rsquo; must not "exist" in the problem. This is done by passing pC[ i ] == C_INF; solvers which don't read costs are forced to read them in order to check this, unless they provide alternative solver-specific ways to accomplish the same tasks. These arcs are "closed", as for the effect of <a class="el" href="classMCFClass.html#ae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc name. ">CloseArc()</a> [see below]. "invalid" costs (== C_INF) are set to 0 in order to being subsequently capable of "opening" them back with <a class="el" href="classMCFClass.html#ab902a23d1c9520a22b79de5d451c3348" title="Restore the previously closed arc name. ">OpenArc()</a> [see below]. The way in which these non-existent arcs are phisically dealt with is solver-specific; in some solvers, for instance, this could be obtained by simply putting their capacity to zero. Details about these issues should be found in the interface of derived classes.</p>
<p>Note that the quadratic part of the objective function, if any, is not dealt with in <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">LoadNet()</a>; it can only be separately provided with <a class="el" href="classMCFClass.html#a4aa1d49c3edafbf4783d579d175070fd">ChgQCoef()</a> [see below]. By default, the problem is linear, i.e., all coefficients of the second-order terms in the objective function are assumed to be zero. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#ac270d18d58fd6fe88164cde1f4c80aff">RelaxIV</a>, <a class="el" href="classSPTree.html#afbfa5c036f9ea67e35005ec77b82214a">SPTree</a>, <a class="el" href="classMCFCplex.html#ac270d18d58fd6fe88164cde1f4c80aff">MCFCplex</a>, <a class="el" href="classMCFZIB.html#ac270d18d58fd6fe88164cde1f4c80aff">MCFZIB</a>, and <a class="el" href="classMCFSimplex.html#ac270d18d58fd6fe88164cde1f4c80aff">MCFSimplex</a>.</p>

</div>
</div>
<a id="a34d79a2f00cf8a2416b2b3e41552e843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d79a2f00cf8a2416b2b3e41552e843">&#9670;&nbsp;</a></span>LoadDMX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoadDMX </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>DMXs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>IsQuad</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a MCF instance in DIMACS standard format from the istream. </p>
<p>The format is the following. The first line must be</p>
<p>p min &lt;number of="" nodes&gt;=""&gt; &lt;number of="" arcs&gt;=""&gt;</p>
<p>Then the node definition lines must be found, in the form</p>
<p>n &lt;node number&gt;=""&gt; &lt;node supply&gt;=""&gt;</p>
<p>Not all nodes need have a node definition line; these are given zero supply, i.e., they are transhipment nodes (supplies are the inverse of deficits, i.e., a node with positive supply is a source node). Finally, the arc definition lines must be found, in the form</p>
<p>a &lt;start node&gt;=""&gt; &lt;end node&gt;=""&gt; &lt;lower bound&gt;=""&gt; &lt;upper bound&gt;=""&gt; &lt;flow cost&gt;=""&gt;</p>
<p>There must be exactly &lt;number of="" arcs&gt;=""&gt; arc definition lines in the file.</p>
<p>This method is <em>not</em> pure virtual because an implementation is provided by the base class, using the <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">LoadNet()</a> method (which <em>is</em> pure virtual). However, the method <em>is</em> virtual to allow derived classes to implement more efficient versions, should they have any reason to do so.</p>
<dl class="section note"><dt>Note</dt><dd>Actually, the file format accepted by LoadDMX (at least in the base class implementation) is more general than the DIMACS standard format, in that it is allowed to mix node and arc definitions in any order, while the DIMACS file requires all node information to appear before all arc information.</dd>
<dd>
Other than for the above, this method is assumed to allow for quadratic* Dimacs files, encoding for convex quadratic separable Min Cost Flow instances. This is a simple extension where each arc descriptor has a sixth field, &lt;quadratic cost&gt;=""&gt;. The provided istream is assumed to be quadratic Dimacs file if IsQuad is true, and a regular linear Dimacs file otherwise. </dd></dl>

</div>
</div>
<a id="a0554708d9abb0e079a8d6f073def9bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0554708d9abb0e079a8d6f073def9bab">&#9670;&nbsp;</a></span>PreProcess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PreProcess </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a smaller/easier equivalent MCF problem. </p>
<p>The data of the instance is changed and the easier one is solved instead of the original one. In the MCF case, preprocessing may involve reducing bounds, identifying disconnected components of the graph etc. However, proprocessing is solver-specific.</p>
<p>This method can be implemented by derived classes in their solver-specific way. Preprocessing may reveal unboundedness or unfeasibility of the problem; if that happens, <a class="el" href="classMCFClass.html#a0554708d9abb0e079a8d6f073def9bab" title="Extract a smaller/easier equivalent MCF problem. ">PreProcess()</a> should properly set the &lsquo;status&rsquo; field, that can then be read with <a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be" title="Returns an int describing the current status of the MCF solver. ">MCFGetStatus()</a> [see below].</p>
<p>Note that preprocessing may destroy all the solution information. Also, it may be allowed to change the data of the problem, such as costs/capacities of the arcs.</p>
<p>A valid preprocessing is doing nothing, and that's what the default implementation of this method (that is <em>not</em> pure virtual) does. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a734f7a51c509f1f28ec605453cf6ed0f">RelaxIV</a>.</p>

</div>
</div>
<a id="ab8e162715d8454f30679c10372db4db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e162715d8454f30679c10372db4db8">&#9670;&nbsp;</a></span>SetPar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set integer parameters of the algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td>is the parameter to be set; the enum MCFParam can be used, but 'par' is an int (every enum is an int) so that the method can be extended by derived classes for the setting of their parameters</td></tr>
    <tr><td class="paramname">value</td><td>is the value to assign to the parameter. <br />
 The base class implementation handles these parameters:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>kMaxIter: the max number of iterations in which the MCF Solver can find an optimal solution (default 0, which means no limit)</li>
<li>kReopt: tells the solver if it has to reoptimize. The implementation in the base class sets a flag, the protected <code>bool</code> field <code>Senstv</code>; if true (default) this field instructs the MCF solver to to try to exploit the information about the latest optimal solution to speedup the optimization of the current problem, while if the field is false the MCF solver should restart the optimization "from scratch" discarding any previous information. Usually reoptimization speeds up the computation considerably, but this is not always true, especially if the data of the problem changes a lot. </li>
</ul>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a12105bbd99b8b7ad7efae3bb0c222b3c">RelaxIV</a>, <a class="el" href="classMCFCplex.html#a12105bbd99b8b7ad7efae3bb0c222b3c">MCFCplex</a>, and <a class="el" href="classMCFSimplex.html#aebda2a23b313bb3ab143e66137ada924">MCFSimplex</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMCFCplex.html#a12105bbd99b8b7ad7efae3bb0c222b3c">MCFCplex::SetPar()</a>, and <a class="el" href="classRelaxIV.html#a12105bbd99b8b7ad7efae3bb0c222b3c">RelaxIV::SetPar()</a>.</p>

</div>
</div>
<a id="a4acd81f913880873c577de03a4fa1959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acd81f913880873c577de03a4fa1959">&#9670;&nbsp;</a></span>SetPar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set float parameters of the algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td>is the parameter to be set; the enum MCFParam can be used, but 'par' is an int (every enum is an int) so that the method can be extended by derived classes for the setting of their parameters</td></tr>
    <tr><td class="paramname">value</td><td>is the value to assign to the parameter. <br />
 The base class implementation handles these parameters:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>kEpsFlw: sets the tolerance for controlling if the flow on an arc is zero to val. This also sets the tolerance for controlling if a node deficit is zero (see kEpsDfct) to val * &lt; max number of nodes &gt;; this value should be safe for graphs in which any node has less than &lt; max number of nodes &gt; adjacent nodes, i.e., for all graphs but for very dense ones with "parallel arcs"</li>
<li>kEpsDfct: sets the tolerance for controlling if a node deficit is zero to val, in case a better value than that autmatically set by kEpsFlw (see above) is available (e.g., val * k would be good if no node has more than k neighbours)</li>
<li>kEpsCst: sets the tolerance for controlling if the reduced cost of an arc is zero to val. A feasible solution satisfying eps-complementary slackness, i.e., such that <p class="formulaDsp">
<img class="formulaDsp" alt="\[ RC[ i , j ] &lt; - eps \Rightarrow X[ i , j ] = U[ ij ] \]" src="form_14.png"/>
</p>
 and <p class="formulaDsp">
<img class="formulaDsp" alt="\[ RC[ i , j ] &gt; eps \Rightarrow X[ i , j ] == 0 , \]" src="form_15.png"/>
</p>
 is known to be ( eps * n )-optimal.</li>
<li>kMaxTime: sets the max time (in seconds) in which the MCF Solver can find an optimal solution (default 0, which means no limit). </li>
</ul>

<p>Reimplemented in <a class="el" href="classMCFCplex.html#a64a55cf140fd8543ab0cf88cc052d8d7">MCFCplex</a>, and <a class="el" href="classMCFSimplex.html#ae6eb12cc8e2e124b236bf84ebeddab70">MCFSimplex</a>.</p>

</div>
</div>
<a id="ac66ea95b63fe61ce67e0f8544f200887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66ea95b63fe61ce67e0f8544f200887">&#9670;&nbsp;</a></span>GetPar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetPar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns one of the integer parameter of the algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td>is the parameter to return [see SetPar( int ) for comments];</td></tr>
    <tr><td class="paramname">val</td><td>upon return, it will contain the value of the parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>The base class implementation handles the parameters kMaxIter and kReopt. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#aebb293732f2fd2767e9ebc5e8ccae338">RelaxIV</a>, and <a class="el" href="classMCFCplex.html#aebb293732f2fd2767e9ebc5e8ccae338">MCFCplex</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMCFCplex.html#aebb293732f2fd2767e9ebc5e8ccae338">MCFCplex::GetPar()</a>, and <a class="el" href="classRelaxIV.html#aebb293732f2fd2767e9ebc5e8ccae338">RelaxIV::GetPar()</a>.</p>

</div>
</div>
<a id="a677caf4176eef1509a0fdf87c0662897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677caf4176eef1509a0fdf87c0662897">&#9670;&nbsp;</a></span>GetPar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetPar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns one of the integer parameter of the algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td>is the parameter to return [see SetPar( double ) for comments];</td></tr>
    <tr><td class="paramname">val</td><td>upon return, it will contain the value of the parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>The base class implementation handles the parameters kEpsFlw, kEpsDfct, kEpsCst, and kMaxTime. </p>

</div>
</div>
<a id="a5441232979a0ac98410d765b04830eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5441232979a0ac98410d765b04830eeb">&#9670;&nbsp;</a></span>SetMCFTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetMCFTime </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TimeIt</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate an OPTtimers object [see OPTtypes.h] to be used for timing the methods of the class. </p>
<p>The time can be read with <a class="el" href="classMCFClass.html#a25ce05b3fabc8d4f80332a02bce2a623" title="Like TimeMCF(double,double) [see above], but returns the total time. ">TimeMCF()</a> [see below]. By default, or if SetMCFTime( false ) is called, no timing is done. Note that, since all the relevant methods ot the class are pure virtual, <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> can only manage the OPTtimers object, but it is due to derived classes to actually implement the timing.</p>
<dl class="section note"><dt>Note</dt><dd>time accumulates over the calls: calling <a class="el" href="classMCFClass.html#a5441232979a0ac98410d765b04830eeb" title="Allocate an OPTtimers object [see OPTtypes.h] to be used for timing the methods of the class...">SetMCFTime()</a>, however, resets the counters, allowing to time specific groups of calls.</dd>
<dd>
of course, setting kMaxTime [see <a class="el" href="classMCFClass.html#ab8e162715d8454f30679c10372db4db8" title="Set integer parameters of the algorithm. ">SetPar()</a> above] to any nonzero value has no effect unless SetMCFTime( true ) has been called. </dd></dl>

</div>
</div>
<a id="ac0d96429d896a2d878a5f057535ab1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d96429d896a2d878a5f057535ab1ee">&#9670;&nbsp;</a></span>SolveMCF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SolveMCF </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solver of the Min Cost Flow Problem. </p>
<p>Attempts to solve the MCF instance currently loaded in the object. </p>

</div>
</div>
<a id="a333e27ad7a73779b096cb70829cbe8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333e27ad7a73779b096cb70829cbe8be">&#9670;&nbsp;</a></span>MCFGetStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MCFGetStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an int describing the current status of the MCF solver. </p>
<p>Possible return values are:</p>
<ul>
<li>kUnSolved <a class="el" href="classMCFClass.html#ac0d96429d896a2d878a5f057535ab1ee" title="Solver of the Min Cost Flow Problem. ">SolveMCF()</a> has not been called yet, or the data of the problem has been changed since the last call;</li>
<li>kOK optimization has been carried out succesfully;</li>
<li>kStopped optimization have been stopped before that the stopping conditions of the solver applied, e.g. because of the maximum allowed number of "iterations" [see SetPar( int )] or the maximum allowed time [see SetPar( double )] has been reached; this is not necessarily an error, as it might just be required to re-call <a class="el" href="classMCFClass.html#ac0d96429d896a2d878a5f057535ab1ee" title="Solver of the Min Cost Flow Problem. ">SolveMCF()</a> giving it more "resources" in order to solve the problem;</li>
<li>kUnfeasible if the current MCF instance is (primal) unfeasible;</li>
<li>kUnbounded if the current MCF instance is (primal) unbounded (this can only happen if the solver actually allows F_INF capacities, which is nonstandard in the interface);</li>
<li>kError if there was an error during the optimization; this typically indicates that computation cannot be resumed, although solver-dependent ways of dealing with solver-dependent errors may exist.</li>
</ul>
<p><a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> has a protected <code>int</code> <code>member</code> <code>status</code> <code>that</code> can be used by derived classes to hold status information and that is returned by the standard implementation of this method. Note that <code>status</code> <code>is</code> an <code>int</code> <code>and</code> not an <code>enum</code> <code></code>, and that an <code>int</code> <code>is</code> returned by this method, in order to allow the derived classes to extend the set of return values if they need to do so. </p>

</div>
</div>
<a id="a884f1180138ddf3df909347b1c85428c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884f1180138ddf3df909347b1c85428c">&#9670;&nbsp;</a></span>MCFGetX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFGetX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the optimal flow solution in the vector F[]. </p>
<p>If nms == 0, F[] will be in "dense" format, i.e., the flow relative to arc &lsquo;i&rsquo; (i in 0 .. m - 1) is written in F[ i ]. If nms != 0, F[] will be in "sparse" format, i.e., the indices of the nonzero elements in the flow solution are written in nms (that is then Inf&lt;Index&gt;()-terminated) and the flow value of arc nms[ i ] is written in F[ i ]. Note that nms is not* guaranteed to be ordered. Also, note that, unlike <a class="el" href="classMCFClass.html#af027cee8179a876a4879c73820c380d1" title="Return a read-only pointer to an internal data structure containing the reduced costs. ">MCFGetRC()</a> and <a class="el" href="classMCFClass.html#a8f1a95d5c707f83ffc6aecba1e7e0e10" title="Return a read-only pointer to an internal data structure containing the node potentials. ">MCFGetPi()</a> [see below], nms is an <em>output</em> of the method.</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). </p>

</div>
</div>
<a id="a4eb307e0707adaef99bb0e08c9e10eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb307e0707adaef99bb0e08c9e10eb8">&#9670;&nbsp;</a></span>MCFGetX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> MCFGetX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only pointer to an internal data structure containing the flow solution in "dense" format. </p>
<p>Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

</div>
</div>
<a id="a7a4966a98c7ffa909057064beb4507a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4966a98c7ffa909057064beb4507a5">&#9670;&nbsp;</a></span>HaveNewX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HaveNewX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if a different (approximately) optimal primal solution is available. </p>
<p>If the method returns true, then any subsequent call to (any form of) <a class="el" href="classMCFClass.html#a4eb307e0707adaef99bb0e08c9e10eb8" title="Return a read-only pointer to an internal data structure containing the flow solution in &quot;dense&quot; form...">MCFGetX()</a> will return a different primal solution w.r.t. the one that was being returned <em>before</em> the call to <a class="el" href="classMCFClass.html#a7a4966a98c7ffa909057064beb4507a5" title="Return true if a different (approximately) optimal primal solution is available. ">HaveNewX()</a>. This solution need not be optimal (although, ideally, it has to be "good); this can be checked by comparing its objective function value, that will be returned by a call to <a class="el" href="classMCFClass.html#a109d7c021feda837d8ca5051fc24b6ea" title="Return the objective function value of the primal solution currently returned by MCFGetX(). ">MCFGetFO()</a> [see below].</p>
<p>Any subsequent call of <a class="el" href="classMCFClass.html#a7a4966a98c7ffa909057064beb4507a5" title="Return true if a different (approximately) optimal primal solution is available. ">HaveNewX()</a> that returns true produces a new solution, until the first that returns false; from then on, no new solutions will be generated until something changes in the problem's data.</p>
<p>Note that a default implementation of <a class="el" href="classMCFClass.html#a7a4966a98c7ffa909057064beb4507a5" title="Return true if a different (approximately) optimal primal solution is available. ">HaveNewX()</a> is provided which is good for those solvers that only produce one optimal primal solution. </p>

</div>
</div>
<a id="a8c573c04800332c86ea31aeb80bbd7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c573c04800332c86ea31aeb80bbd7b1">&#9670;&nbsp;</a></span>MCFGetPi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFGetPi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the optimal node potentials in the vector P[]. </p>
<p>If nms == 0, the node potential of node &lsquo;i&rsquo; (i in 0 .. n - 1) is written in P[ i ] (note that here node names always start from zero, regardless to the value of USENAME0). If nms != 0, it must point to a vector of indices in 0 .. n - 1 (ordered in increasing sense and Inf&lt;Index&gt;()-terminated), and the node potential of nms[ i ] is written in P[ i ]. Note that, unlike <a class="el" href="classMCFClass.html#a4eb307e0707adaef99bb0e08c9e10eb8" title="Return a read-only pointer to an internal data structure containing the flow solution in &quot;dense&quot; form...">MCFGetX()</a> above, nms is an <em>input</em> of the method.</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the nodes &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFn() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to nodes which are <em>both</em> in nms[] and whose index is in the correct range are returned. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#abb97afaf7df33019f1b728138a254d6d">RelaxIV</a>.</p>

</div>
</div>
<a id="a8f1a95d5c707f83ffc6aecba1e7e0e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1a95d5c707f83ffc6aecba1e7e0e10">&#9670;&nbsp;</a></span>MCFGetPi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> MCFGetPi </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only pointer to an internal data structure containing the node potentials. </p>
<p>Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a2eb8e4b396fb6d82d56dcb9b7fbe871b">RelaxIV</a>, and <a class="el" href="classSPTree.html#a2eb8e4b396fb6d82d56dcb9b7fbe871b">SPTree</a>.</p>

</div>
</div>
<a id="a87b2b6516a7874ac55145312bd2d55bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b2b6516a7874ac55145312bd2d55bb">&#9670;&nbsp;</a></span>HaveNewPi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HaveNewPi </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if a different (approximately) optimal dual solution is available. </p>
<p>If the method returns true, then any subsequent call to (any form of) <a class="el" href="classMCFClass.html#a8f1a95d5c707f83ffc6aecba1e7e0e10" title="Return a read-only pointer to an internal data structure containing the node potentials. ">MCFGetPi()</a> will return a different dual solution, and <a class="el" href="classMCFClass.html#af027cee8179a876a4879c73820c380d1" title="Return a read-only pointer to an internal data structure containing the reduced costs. ">MCFGetRC()</a> [see below] will return the corresponding reduced costs. The new solution need not be optimal (although, ideally, it has to be "good); this can be checked by comparing its objective function value, that will be returned by a call to <a class="el" href="classMCFClass.html#aca66f278ea62640af8e54590c687d715" title="Return the objective function value of the dual solution currently returned by MCFGetPi() / MCFGetRC(...">MCFGetDFO()</a> [see below].</p>
<p>Any subsequent call of <a class="el" href="classMCFClass.html#a87b2b6516a7874ac55145312bd2d55bb" title="Return true if a different (approximately) optimal dual solution is available. ">HaveNewPi()</a> that returns true produces a new solution, until the first that returns false; from then on, no new solutions will be generated until something changes in the problem's data.</p>
<p>Note that a default implementation of <a class="el" href="classMCFClass.html#a87b2b6516a7874ac55145312bd2d55bb" title="Return true if a different (approximately) optimal dual solution is available. ">HaveNewPi()</a> is provided which is good for those solvers that only produce one optimal dual solution. </p>

</div>
</div>
<a id="a361d84ae42041fdbf3824d45fc4c54aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361d84ae42041fdbf3824d45fc4c54aa">&#9670;&nbsp;</a></span>MCFGetRC() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFGetRC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>CR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the reduced costs corresponding to the current dual solution in RC[]. </p>
<p>If nms == 0, the reduced cost of arc &lsquo;i&rsquo; (i in 0 .. m - 1) is written in RC[ i ]; if nms != 0, it must point to a vector of indices in 0 .. m - 1 (ordered in increasing sense and Inf&lt;Index&gt;()-terminated), and the reduced cost of arc nms[ i ] is written in RC[ i ]. Note that, unlike <a class="el" href="classMCFClass.html#a4eb307e0707adaef99bb0e08c9e10eb8" title="Return a read-only pointer to an internal data structure containing the flow solution in &quot;dense&quot; form...">MCFGetX()</a> above, nms is an <em>input</em> of the method.</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms[] and whose index is in the correct range are returned.</p>
<dl class="section note"><dt>Note</dt><dd>the output of <a class="el" href="classMCFClass.html#af027cee8179a876a4879c73820c380d1" title="Return a read-only pointer to an internal data structure containing the reduced costs. ">MCFGetRC()</a> will change after any call to <a class="el" href="classMCFClass.html#a87b2b6516a7874ac55145312bd2d55bb" title="Return true if a different (approximately) optimal dual solution is available. ">HaveNewPi()</a> [see above] which returns true. </dd></dl>

</div>
</div>
<a id="af027cee8179a876a4879c73820c380d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af027cee8179a876a4879c73820c380d1">&#9670;&nbsp;</a></span>MCFGetRC() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> MCFGetRC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only pointer to an internal data structure containing the reduced costs. </p>
<p>Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method.</p>
<dl class="section note"><dt>Note</dt><dd>the output of <a class="el" href="classMCFClass.html#af027cee8179a876a4879c73820c380d1" title="Return a read-only pointer to an internal data structure containing the reduced costs. ">MCFGetRC()</a> will change after any call to <a class="el" href="classMCFClass.html#a87b2b6516a7874ac55145312bd2d55bb" title="Return true if a different (approximately) optimal dual solution is available. ">HaveNewPi()</a> [see above] which returns true. </dd></dl>

</div>
</div>
<a id="a7c103b582c910ccfda354032aae5722e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c103b582c910ccfda354032aae5722e">&#9670;&nbsp;</a></span>MCFGetRC() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> MCFGetRC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the reduced cost of the i-th arc. </p>
<p>This information should be cheapily available in most implementations.</p>
<dl class="section note"><dt>Note</dt><dd>the output of <a class="el" href="classMCFClass.html#af027cee8179a876a4879c73820c380d1" title="Return a read-only pointer to an internal data structure containing the reduced costs. ">MCFGetRC()</a> will change after any call to <a class="el" href="classMCFClass.html#a87b2b6516a7874ac55145312bd2d55bb" title="Return true if a different (approximately) optimal dual solution is available. ">HaveNewPi()</a> [see above] which returns true. </dd></dl>

</div>
</div>
<a id="a109d7c021feda837d8ca5051fc24b6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109d7c021feda837d8ca5051fc24b6ea">&#9670;&nbsp;</a></span>MCFGetFO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a> MCFGetFO </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the objective function value of the primal solution currently returned by <a class="el" href="classMCFClass.html#a4eb307e0707adaef99bb0e08c9e10eb8" title="Return a read-only pointer to an internal data structure containing the flow solution in &quot;dense&quot; form...">MCFGetX()</a>. </p>
<p>If <a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be" title="Returns an int describing the current status of the MCF solver. ">MCFGetStatus()</a> == kOK, this is guaranteed to be the optimal objective function value of the problem (to within the optimality tolerances), but only prior to any call to <a class="el" href="classMCFClass.html#a7a4966a98c7ffa909057064beb4507a5" title="Return true if a different (approximately) optimal primal solution is available. ">HaveNewX()</a> that returns true. <a class="el" href="classMCFClass.html#a109d7c021feda837d8ca5051fc24b6ea" title="Return the objective function value of the primal solution currently returned by MCFGetX(). ">MCFGetFO()</a> typically returns Inf&lt;FONumber&gt;() if <a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be" title="Returns an int describing the current status of the MCF solver. ">MCFGetStatus()</a> == kUnfeasible and</p><ul>
<li>Inf&lt;FONumber&gt;() if <a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be" title="Returns an int describing the current status of the MCF solver. ">MCFGetStatus()</a> == kUnbounded. If <a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be" title="Returns an int describing the current status of the MCF solver. ">MCFGetStatus()</a> == kStopped and <a class="el" href="classMCFClass.html#a109d7c021feda837d8ca5051fc24b6ea" title="Return the objective function value of the primal solution currently returned by MCFGetX(). ">MCFGetFO()</a> returns a finite value, it must be an upper bound on the optimal objective function value (typically, the objective function value of one primal feasible solution). </li>
</ul>

<p>Implemented in <a class="el" href="classSPTree.html#a55b9b095d557852a91b68c973236518a">SPTree</a>.</p>

</div>
</div>
<a id="aca66f278ea62640af8e54590c687d715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca66f278ea62640af8e54590c687d715">&#9670;&nbsp;</a></span>MCFGetDFO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a> MCFGetDFO </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the objective function value of the dual solution currently returned by <a class="el" href="classMCFClass.html#a8f1a95d5c707f83ffc6aecba1e7e0e10" title="Return a read-only pointer to an internal data structure containing the node potentials. ">MCFGetPi()</a> / <a class="el" href="classMCFClass.html#af027cee8179a876a4879c73820c380d1" title="Return a read-only pointer to an internal data structure containing the reduced costs. ">MCFGetRC()</a>. </p>
<p>This value (possibly) changes after any call to <a class="el" href="classMCFClass.html#a87b2b6516a7874ac55145312bd2d55bb" title="Return true if a different (approximately) optimal dual solution is available. ">HaveNewPi()</a> that returns true. The relations between <a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be" title="Returns an int describing the current status of the MCF solver. ">MCFGetStatus()</a> and <a class="el" href="classMCFClass.html#aca66f278ea62640af8e54590c687d715" title="Return the objective function value of the dual solution currently returned by MCFGetPi() / MCFGetRC(...">MCFGetDFO()</a> are analogous to these of <a class="el" href="classMCFClass.html#a109d7c021feda837d8ca5051fc24b6ea" title="Return the objective function value of the primal solution currently returned by MCFGetX(). ">MCFGetFO()</a>, except that a finite value corresponding to kStopped must be a lower bound on the optimal objective function value (typically, the objective function value one dual feasible solution).</p>
<p>A default implementation is provided for <a class="el" href="classMCFClass.html#aca66f278ea62640af8e54590c687d715" title="Return the objective function value of the dual solution currently returned by MCFGetPi() / MCFGetRC(...">MCFGetDFO()</a>, which is good for MCF solvers where the primal and dual optimal solution values always are identical (except if the problem is unfeasible/unbounded). </p>

</div>
</div>
<a id="a30483c3e5699b77f528c2e6f33c80ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30483c3e5699b77f528c2e6f33c80ece">&#9670;&nbsp;</a></span>MCFGetUnfCut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> MCFGetUnfCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>Cut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an unfeasibility certificate. </p>
<p>In an unfeasible MCF problem, unfeasibility can always be reduced to the existence of a cut (subset of nodes of the graph) such as either:</p>
<ul>
<li>the inverse of the deficit of the cut (the sum of all the deficits of the nodes in the cut) is larger than the forward capacity of the cut (sum of the capacities of forward arcs in the cut); that is, the nodes in the cut globally produce more flow than can be routed to sinks outside the cut;</li>
<li>the deficit of the cut is larger than the backward capacity of the cut (sum of the capacities of backward arcs in the cut); that is, the nodes in the cut globally require more flow than can be routed to them from sources outside the cut.</li>
</ul>
<p>When detecting unfeasibility, MCF solvers are typically capable to provide one such cut. This information can be useful - typically, the only way to make the problem feasible is to increase the capacity of at least one of the forward/backward arcs of the cut -, and this method is provided for getting it. It can be called only if <a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be" title="Returns an int describing the current status of the MCF solver. ">MCFGetStatus()</a> == kUnfeasible, and should write in Cut the set of names of nodes in the unfeasible cut (note that node names depend on USENAME0), Inf&lt;Index&gt;()-terminated, returning the deficit of the cut (which allows to distinguish which of the two cases above hold). In general, no special properties can be expected from the returned cut, but solvers should be able to provide e.g. "small" cuts.</p>
<p>However, not all solvers may be (easily) capable of providing this information; thus, returning 0 (no cut) is allowed, as in the base class implementation, to signify that this information is not available. </p>

</div>
</div>
<a id="a88fa193007f0bc6ef751664a9f4c75a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88fa193007f0bc6ef751664a9f4c75a2">&#9670;&nbsp;</a></span>MCFGetUnbCycl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFGetUnbCycl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>ArcPred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an unboundedness certificate. </p>
<p>In an unbounded MCF problem, unboundedness can always be reduced to the existence of a directed cycle with negative cost and all arcs having infinite capacity. When detecting unboundedness, MCF solvers are typically capable to provide one such cycle. This information can be useful, and this method is provided for getting it. It can be called only if <a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be" title="Returns an int describing the current status of the MCF solver. ">MCFGetStatus()</a> == kUnbounded, and writes in Pred[] and ArcPred[], respectively, the node and arc predecessor function of the cycle. That is, if node &lsquo;i&rsquo; belongs to the cycle then &lsquo;Pred[ i ]&rsquo; contains the name of the predecessor of &lsquo;j&rsquo; of &lsquo;i&rsquo; in the cycle (note that node names depend on USENAME0), and &lsquo;ArcPred[ i ]&rsquo; contains the index of the arc joining the two (note that in general there may be multiple copies of each arc). Entries of the vectors for nodes not belonging to the cycle are in principle undefined, and the name of one node belonging to the cycle is returned by the method. Note that if there are multiple cycles with negative costs this method will return just one of them (finding the cycle with most negative cost is an NO-hard problem), although solvers should be able to produce cycles with "large negative" cost.</p>
<p>However, not all solvers may be (easily) capable of providing this information; thus, returning Inf&lt;Index&gt;() is allowed, as in the base class implementation, to signify that this information is not available. </p>

</div>
</div>
<a id="a995a05ecaa6ece4be3afbddbb36b2c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995a05ecaa6ece4be3afbddbb36b2c4e">&#9670;&nbsp;</a></span>MCFGetState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a> MCFGetState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save the state of the MCF solver. </p>
<p>The <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> interface supports the notion of saving and restoring the state of the MCF solver, such as the current/optimal basis in a simplex solver. The "empty" class <a class="el" href="classMCFClass_1_1MCFState.html" title="Base class for representing the internal state of the MCF algorithm. ">MCFState</a> is defined as a placeholder for state descriptions.</p>
<p><a class="el" href="classMCFClass.html#a995a05ecaa6ece4be3afbddbb36b2c4e" title="Save the state of the MCF solver. ">MCFGetState()</a> creates and returns a pointer to an object of (a proper derived class of) class <a class="el" href="classMCFClass_1_1MCFState.html" title="Base class for representing the internal state of the MCF algorithm. ">MCFState</a> which describes the current state of the MCF solver. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a8d5216446bb15f330652c236c1f37b28">RelaxIV</a>.</p>

</div>
</div>
<a id="ac14589cd80aed231b6fc7da247f50601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14589cd80aed231b6fc7da247f50601">&#9670;&nbsp;</a></span>MCFPutState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFPutState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a>&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore the solver to the state in which it was when the state &lsquo;S&rsquo; was created with <a class="el" href="classMCFClass.html#a995a05ecaa6ece4be3afbddbb36b2c4e" title="Save the state of the MCF solver. ">MCFGetState()</a> [see above]. </p>
<p>The typical use of this method is the following: a MCF problem is solved and the "optimal state" is set aside. Then the problem changes and it is re-solved. Then, the problem has to be changed again to a form that is close to the original one but rather different from the second one (think of a long backtracking in a Branch &amp; Bound) to which the current "state" referes. Then, the old optimal state can be expected to provide a better starting point for reoptimization [see ReOptimize() below].</p>
<p>Note, however, that the state is only relative to the optimization process, i.e., this operation is meaningless if the data of the problem has changed in the meantime. So, if a state has to be used for speeding up reoptimization, the following has to be done:</p>
<ul>
<li>first, the data of the solver is brought back to <em>exactly</em> the same as it was at the moment where the state &lsquo;S&rsquo; was created (prior than this operation a ReOptimize( false ) call is probably advisable);</li>
<li>then, <a class="el" href="classMCFClass.html#ac14589cd80aed231b6fc7da247f50601" title="Restore the solver to the state in which it was when the state S was created with MCFGetState() [...">MCFPutState()</a> is called (and ReOptimize( true ) is called);</li>
<li>only afterwards the data of the problem is changed to the final state and the problem is solved.</li>
</ul>
<p>A "put state" operation does not "deplete" the state, which can therefore be used more than once. Indeed, a state is constructed inside the solver for each call to <a class="el" href="classMCFClass.html#a995a05ecaa6ece4be3afbddbb36b2c4e" title="Save the state of the MCF solver. ">MCFGetState()</a>, but the solver never deletes statuses; this has to be done on the outside when they are no longer needed (the solver must be "resistent" to deletion of the state at any moment).</p>
<p>Since not all the MCF solvers reoptimize (efficiently enough to make these operations worth), an "empty" implementation that does nothing is provided by the base class. </p>

</div>
</div>
<a id="a779a8829874de569dc0e09f40b6cd569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779a8829874de569dc0e09f40b6cd569">&#9670;&nbsp;</a></span>TimeMCF() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TimeMCF </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t_ss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Time the code. </p>
<p>If called within any of the methods of the class that are "actively timed" (this depends on the subclasses), this method returns the user and sistem time (in seconds) since the start of that method. If methods that are actively timed call other methods that are actively timed, <a class="el" href="classMCFClass.html#a25ce05b3fabc8d4f80332a02bce2a623" title="Like TimeMCF(double,double) [see above], but returns the total time. ">TimeMCF()</a> returns the (...) time since the beginning of the outer* actively timed method. If called outside of any actively timed method, this method returns the (...) time spent in all the previous executions of all the actively timed methods of the class.</p>
<p>Implementing the proper calls to MCFt-&gt;Start() and MCFt-&gt;Stop() is due to derived classes; these should at least be placed at the beginning and at the end, respectively, of <a class="el" href="classMCFClass.html#ac0d96429d896a2d878a5f057535ab1ee" title="Solver of the Min Cost Flow Problem. ">SolveMCF()</a> and presumably the Chg***() methods, that is, at least these methods should be "actively timed". </p>

</div>
</div>
<a id="a25ce05b3fabc8d4f80332a02bce2a623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ce05b3fabc8d4f80332a02bce2a623">&#9670;&nbsp;</a></span>TimeMCF() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double TimeMCF </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like TimeMCF(double,double) [see above], but returns the total time. </p>

</div>
</div>
<a id="a41b70e84f98f30b408d0ffb191ff4442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b70e84f98f30b408d0ffb191ff4442">&#9670;&nbsp;</a></span>CheckPSol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CheckPSol </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the primal solution returned by the solver is primal feasible. </p>
<p>(to within the tolerances set by SetPar(kEps****) [see above], if any). Also, check that the objective function value is correct.</p>
<p>This method is implemented by the base class, using the above methods for collecting the solutions and the methods of the next section for reading the data of the problem; as such, they will work for any derived class that properly implements all these methods. </p>

</div>
</div>
<a id="a81bd6bc3b87534b4a67d0d93abedbd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bd6bc3b87534b4a67d0d93abedbd93">&#9670;&nbsp;</a></span>CheckDSol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CheckDSol </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the dual solution returned by the solver is dual feasible. </p>
<p>(to within the tolerances set by SetPar(kEps****) [see above], if any). Also, check that the objective function value is correct.</p>
<p>This method is implemented by the base class, using the above methods for collecting the solutions and the methods of the next section for reading the data of the problem; as such, they will work for any derived class that properly implements all these methods. </p>

</div>
</div>
<a id="acfb1bca6eb363c912c45c587f4bc214b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb1bca6eb363c912c45c587f4bc214b">&#9670;&nbsp;</a></span>MCFnmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFnmax </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum number of nodes for this instance of <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a>. </p>
<p>The implementation of the method in the base class returns the protected fields <code>nmax</code>, which is provided for derived classes to hold this information. </p>

</div>
</div>
<a id="af63cff04d49de9f84b9ddc8585334690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63cff04d49de9f84b9ddc8585334690">&#9670;&nbsp;</a></span>MCFmmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFmmax </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum number of arcs for this instance of <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a>. </p>
<p>The implementation of the method in the base class returns the protected fields <code>mmax</code>, which is provided for derived classes to hold this information. </p>

</div>
</div>
<a id="a6438187f454e795c03a850bfab31be84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6438187f454e795c03a850bfab31be84">&#9670;&nbsp;</a></span>MCFn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of nodes in the current graph. </p>
<p>The implementation of the method in the base class returns the protected fields <code>n</code>, which is provided for derived classes to hold this information. </p>

</div>
</div>
<a id="ab4d5a0d0fc49882de0b4eb3146f1b7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d5a0d0fc49882de0b4eb3146f1b7a6">&#9670;&nbsp;</a></span>MCFm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFm </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of arcs in the current graph. </p>
<p>The implementation of the method in the base class returns the protected fields <code>m</code>, which is provided for derived classes to hold this information. </p>

</div>
</div>
<a id="aa2314bf81483649dd1cb9dada0de6832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2314bf81483649dd1cb9dada0de6832">&#9670;&nbsp;</a></span>MCFArcs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFArcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>Startv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>Endv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the starting (tail) and ending (head) nodes of the arcs in Startv[] and Endv[]. </p>
<p>If nms == 0, then the information relative to all arcs is written into Startv[] and Endv[], otherwise Startv[ i ] and Endv[ i ] contain the information relative to arc nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms and whose index is in the correct range are returned.</p>
<p>Startv or Endv can be 0, meaning that only the other information is required.</p>
<dl class="section note"><dt>Note</dt><dd>If USENAME0 == 0 then the returned node names will be in the range 1 .. n, while if USENAME0 == 1 the returned node names will be in the range 0 .. n - 1.</dd>
<dd>
If the graph is "dynamic", be careful to use <a class="el" href="classMCFClass.html#a6438187f454e795c03a850bfab31be84" title="Return the number of nodes in the current graph. ">MCFn()</a> e <a class="el" href="classMCFClass.html#ab4d5a0d0fc49882de0b4eb3146f1b7a6" title="Return the number of arcs in the current graph. ">MCFm()</a> to properly choose the dimension of nodes and arcs arrays. </dd></dl>

</div>
</div>
<a id="ae3f1b21bfe422e2d54de0dc56231599b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f1b21bfe422e2d54de0dc56231599b">&#9670;&nbsp;</a></span>MCFSNde()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFSNde </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the starting (tail) node of the arc &lsquo;i&rsquo;. </p>
<dl class="section note"><dt>Note</dt><dd>If USENAME0 == 0 then the returned node names will be in the range 1 .. n, while if USENAME0 == 1 the returned node names will be in the range 0 .. n - 1. </dd></dl>

</div>
</div>
<a id="a1b0d5b8f2dfd729783e7c0fd604dc896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0d5b8f2dfd729783e7c0fd604dc896">&#9670;&nbsp;</a></span>MCFENde()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFENde </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ending (head) node of the arc &lsquo;i&rsquo;. </p>
<dl class="section note"><dt>Note</dt><dd>If USENAME0 == 0 then the returned node names will be in the range 1 .. n, while if USENAME0 == 1 the returned node names will be in the range 0 .. n - 1. </dd></dl>

</div>
</div>
<a id="a3aeea0e6fd59fc54c2d7a0d21099ea21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aeea0e6fd59fc54c2d7a0d21099ea21">&#9670;&nbsp;</a></span>MCFSNdes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> MCFSNdes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only pointer to an internal vector containing the starting (tail) nodes for each arc. </p>
<p>Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a267511f5ada8f10c2e5f658d5821f07c">RelaxIV</a>.</p>

</div>
</div>
<a id="a5494247213fd86574798bba97a2eb604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5494247213fd86574798bba97a2eb604">&#9670;&nbsp;</a></span>MCFENdes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> MCFENdes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only pointer to an internal vector containing the ending (head) nodes for each arc. </p>
<p>Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a280f29b091019d48552297533a1ff48a">RelaxIV</a>.</p>

</div>
</div>
<a id="ab6dbac4cde9477589de653081986abb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6dbac4cde9477589de653081986abb4">&#9670;&nbsp;</a></span>MCFCosts() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFCosts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>Costv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the arc costs into Costv[]. </p>
<p>If nms == 0, then all the costs are written, otherwise Costv[ i ] contains the information relative to arc nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms and whose index is in the correct range are returned. </p>

</div>
</div>
<a id="ac666df7c1e7ed07c0f7574ec307c9e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac666df7c1e7ed07c0f7574ec307c9e82">&#9670;&nbsp;</a></span>MCFCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> MCFCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cost of the i-th arc. </p>

</div>
</div>
<a id="a75dcdf78883ef28452a4698aaa6bf14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75dcdf78883ef28452a4698aaa6bf14b">&#9670;&nbsp;</a></span>MCFCosts() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> MCFCosts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only pointer to an internal vector containing the arc costs. </p>
<p>Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

</div>
</div>
<a id="acd08873d1e15db41bf42648226f8feb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd08873d1e15db41bf42648226f8feb1">&#9670;&nbsp;</a></span>MCFQCoef() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>Qv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stp</td><td>Write the quadratic coefficients of the arc costs into Qv[]. If nms == 0, then all the costs are written, otherwise Costv[ i ] contains the information relative to arc nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</td></tr>
  </table>
  </dd>
</dl>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms and whose index is in the correct range are returned.</p>
<p>Note that the method is <em>not</em> pure virtual: an implementation is provided for "pure linear" MCF solvers that only work with all zero quadratic coefficients. </p>

</div>
</div>
<a id="ab9227949082669e0e9ca0c545406f1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9227949082669e0e9ca0c545406f1f4">&#9670;&nbsp;</a></span>MCFQCoef() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> MCFQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Return the quadratic coefficients of the cost of the i-th arc. Note that the method is <em>not</em> pure virtual: an implementation is provided for "pure
   linear" MCF solvers that only work with all zero quadratic coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeea78552d525e5ce61f3e3887774cc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea78552d525e5ce61f3e3887774cc11">&#9670;&nbsp;</a></span>MCFQCoef() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> MCFQCoef </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only pointer to an internal vector containing the arc costs. </p>
<p>Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready (such as "pure linear" MCF solvers that only work with all zero quadratic coefficients) does not need to implement the method. </p>

</div>
</div>
<a id="a999b9738aa5cb925c5b4a799ed6d4838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999b9738aa5cb925c5b4a799ed6d4838">&#9670;&nbsp;</a></span>MCFUCaps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFUCaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>UCapv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the arc capacities into UCapv[]. </p>
<p>If nms == 0, then all the capacities are written, otherwise UCapv[ i ] contains the information relative to arc nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms and whose index is in the correct range are returned. </p>

</div>
</div>
<a id="a3af18f0859dd6ddea9d29ed39c9b27a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af18f0859dd6ddea9d29ed39c9b27a3">&#9670;&nbsp;</a></span>MCFUCap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> MCFUCap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the capacity of the i-th arc. </p>

</div>
</div>
<a id="aae54f2f08242d5fd631eb613d82e4d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae54f2f08242d5fd631eb613d82e4d1c">&#9670;&nbsp;</a></span>MCFUCaps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> MCFUCaps </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only pointer to an internal vector containing the arc capacities. </p>
<p>Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

</div>
</div>
<a id="a99e2d376efc0d9552a62f9b71512b563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e2d376efc0d9552a62f9b71512b563">&#9670;&nbsp;</a></span>MCFDfcts() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFDfcts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>Dfctv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the node deficits into Dfctv[]. </p>
<p>If nms == 0, then all the defcits are written, otherwise Dfctvv[ i ] contains the information relative to node nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the nodes &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFn() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to nodes which are <em>both</em> in nms and whose index is in the correct range are returned.</p>
<dl class="section note"><dt>Note</dt><dd>Here node "names" (strt and stp, those contained in nms[] or &lsquo;i&rsquo; in <a class="el" href="classMCFClass.html#a81e07cb46404db5a9fd83075a0908208" title="Return the deficit of the i-th node. ">MCFDfct()</a>) go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit is returned by MCFDfcts( Dfctv , 0 , 0 , 1 ). </dd></dl>

</div>
</div>
<a id="a81e07cb46404db5a9fd83075a0908208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e07cb46404db5a9fd83075a0908208">&#9670;&nbsp;</a></span>MCFDfct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> MCFDfct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the deficit of the i-th node. </p>
<dl class="section note"><dt>Note</dt><dd>Here node "names" go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit is returned by MCFDfct( 0 ). </dd></dl>

</div>
</div>
<a id="ad7e8d115e0f2bd90e1b65a573cb46ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e8d115e0f2bd90e1b65a573cb46ae4">&#9670;&nbsp;</a></span>MCFDfcts() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> MCFDfcts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only pointer to an internal vector containing the node deficits. </p>
<p>Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method.</p>
<dl class="section note"><dt>Note</dt><dd>Here node "names" go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit is contained in <a class="el" href="classMCFClass.html#ad7e8d115e0f2bd90e1b65a573cb46ae4" title="Return a read-only pointer to an internal vector containing the node deficits. ">MCFDfcts()</a>[ 0 ]. </dd></dl>

</div>
</div>
<a id="acd008d9548bf3e1aef1291864171bb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd008d9548bf3e1aef1291864171bb2d">&#9670;&nbsp;</a></span>WriteMCF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WriteMCF </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>oStrm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frmt</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the current MCF problem to an ostream. </p>
<p>This may be useful e.g. for debugging purposes.</p>
<p>The base <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> class provides output in two different formats, depending on the value of the parameter frmt:</p>
<ul>
<li>kDimacs the problem is written in DIMACS standard format, read by most MCF codes available;</li>
<li>kMPS the problem is written in the "modern version" (tab-separated) of the MPS format, read by most LP/MIP solvers;<ul>
<li>kFWMPS the problem is written in the "old version" (fixed width fields) of the MPS format; this is read by most LP/MIP solvers, but some codes still require the old format.</li>
</ul>
</li>
</ul>
<p>The implementation of <a class="el" href="classMCFClass.html#acd008d9548bf3e1aef1291864171bb2d" title="Write the current MCF problem to an ostream. ">WriteMCF()</a> in the base class uses all the above methods for reading the data; as such it will work for any derived class that properly implements this part of the interface, but it may not be very efficient. Thus, the method is virtual to allow the derived classes to either re-implement <a class="el" href="classMCFClass.html#acd008d9548bf3e1aef1291864171bb2d" title="Write the current MCF problem to an ostream. ">WriteMCF()</a> for the above two formats in a more efficient way, and/or to extend it to support other solver-specific formats.</p>
<dl class="section note"><dt>Note</dt><dd>None of the above two formats supports quadratic MCFs, so if nonzero quadratic coefficients are present, they are just ignored. </dd></dl>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#ae1d1711d5cdab205d15363b40a6686ee">RelaxIV</a>.</p>

<p class="reference">References <a class="el" href="group__MCFCLASS__MACROS.html#ga74cc96ffa32533b7eff040b5ffee5e06">USENAME0</a>.</p>

</div>
</div>
<a id="aedaaa3c7820183c210ff8b1cc716c27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedaaa3c7820183c210ff8b1cc716c27d">&#9670;&nbsp;</a></span>ChgCosts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgCosts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>NCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the arc costs. </p>
<p>In particular, change the costs that are:</p>
<ul>
<li>listed in into the vector of indices &lsquo;nms&rsquo; (ordered in increasing sense and Inf&lt;Index&gt;()-terminated),</li>
<li><em>and</em> whose name belongs to the interval [&lsquo;strt&rsquo;, &lsquo;stp&rsquo;).</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th cost will be changed to NCost[ i ]. If nms == 0 (as the default), <em>all</em> the entries in the given range will be changed; if stp &gt; <a class="el" href="classMCFClass.html#ab4d5a0d0fc49882de0b4eb3146f1b7a6" title="Return the number of arcs in the current graph. ">MCFm()</a>, then the smaller bound is used.</p>
<dl class="section note"><dt>Note</dt><dd>changing the costs of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs which have not been closed/deleted [see <a class="el" href="classMCFClass.html#ae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc name. ">CloseArc()</a> / <a class="el" href="classMCFClass.html#ae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc name. ">DelArc()</a> below and <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="a41ab6d76a454b3f792665cce35a250f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ab6d76a454b3f792665cce35a250f3">&#9670;&nbsp;</a></span>ChgCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a>&#160;</td>
          <td class="paramname"><em>NCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the cost of the i-th arc. </p>
<dl class="section note"><dt>Note</dt><dd>changing the costs of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs which have not been closed/deleted [see <a class="el" href="classMCFClass.html#ae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc name. ">CloseArc()</a> / <a class="el" href="classMCFClass.html#ae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc name. ">DelArc()</a> below and <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="a4aa1d49c3edafbf4783d579d175070fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa1d49c3edafbf4783d579d175070fd">&#9670;&nbsp;</a></span>ChgQCoef() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>NQCoef</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stp</td><td>Change the quadratic coefficients of the arc costs. In particular, change the coefficients that are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>listed in into the vector of indices &lsquo;nms&rsquo; (ordered in increasing sense and Inf&lt;Index&gt;()-terminated),</li>
<li><em>and</em> whose name belongs to the interval [&lsquo;strt&rsquo;, &lsquo;stp&rsquo;).</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th cost will be changed to NCost[ i ]. If nms == 0 (as the default), <em>all</em> the entries in the given range will be changed; if stp &gt; <a class="el" href="classMCFClass.html#ab4d5a0d0fc49882de0b4eb3146f1b7a6" title="Return the number of arcs in the current graph. ">MCFm()</a>, then the smaller bound is used. If NQCoef == 0, all the specified coefficients are set to zero.</p>
<p>Note that the method is <em>not</em> pure virtual: an implementation is provided for "pure linear" MCF solvers that only work with all zero quadratic coefficients.</p>
<dl class="section note"><dt>Note</dt><dd>changing the costs of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs which have not been closed/deleted [see <a class="el" href="classMCFClass.html#ae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc name. ">CloseArc()</a> / <a class="el" href="classMCFClass.html#ae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc name. ">DelArc()</a> below and <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="a4df44e18d436b2500e5608d6ab2d58ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df44e18d436b2500e5608d6ab2d58ad">&#9670;&nbsp;</a></span>ChgQCoef() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a>&#160;</td>
          <td class="paramname"><em>NQCoef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NQCoef</td><td>Change the quadratic coefficient of the cost of the i-th arc.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the method is <em>not</em> pure virtual: an implementation is provided for "pure linear" MCF solvers that only work with all zero quadratic coefficients.</p>
<dl class="section note"><dt>Note</dt><dd>changing the costs of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs which have not been closed/deleted [see <a class="el" href="classMCFClass.html#ae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc name. ">CloseArc()</a> / <a class="el" href="classMCFClass.html#ae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc name. ">DelArc()</a> below and <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="ad548db90d9914f8a40bbb4823f274ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad548db90d9914f8a40bbb4823f274ccc">&#9670;&nbsp;</a></span>ChgUCaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgUCaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>NCap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the arc capacities. </p>
<p>In particular, change the capacities that are:</p>
<ul>
<li>listed in into the vector of indices &lsquo;nms&rsquo; (ordered in increasing sense and Inf&lt;Index&gt;()-terminated),</li>
<li><em>and</em> whose name belongs to the interval [&lsquo;strt&rsquo;, &lsquo;stp&rsquo;).</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th capacity will be changed to NCap[ i ]. If nms == 0 (as the default), <em>all</em> the entries in the given range will be changed; if stp &gt; <a class="el" href="classMCFClass.html#ab4d5a0d0fc49882de0b4eb3146f1b7a6" title="Return the number of arcs in the current graph. ">MCFm()</a>, then the smaller bound is used.</p>
<dl class="section note"><dt>Note</dt><dd>changing the capacities of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs that have not been closed/deleted [see <a class="el" href="classMCFClass.html#ae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc name. ">CloseArc()</a> / <a class="el" href="classMCFClass.html#ae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc name. ">DelArc()</a> below and <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="a832883594b6ea5a00fabc9f4be41d9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832883594b6ea5a00fabc9f4be41d9e5">&#9670;&nbsp;</a></span>ChgUCap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgUCap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a>&#160;</td>
          <td class="paramname"><em>NCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the capacity of the i-th arc. </p>
<dl class="section note"><dt>Note</dt><dd>changing the capacities of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs that have not been closed/deleted [see <a class="el" href="classMCFClass.html#ae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc name. ">CloseArc()</a> / <a class="el" href="classMCFClass.html#ae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc name. ">DelArc()</a> below and <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="a50ee5aaf0f8b39a1edec078828ade458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ee5aaf0f8b39a1edec078828ade458">&#9670;&nbsp;</a></span>ChgDfcts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgDfcts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>NDfct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the node deficits. </p>
<p>In particular, change the deficits that are:</p>
<ul>
<li>listed in into the vector of indices &lsquo;nms&rsquo; (ordered in increasing sense and Inf&lt;Index&gt;()-terminated),</li>
<li><em>and</em> whose name belongs to the interval [&lsquo;strt&rsquo;, &lsquo;stp&rsquo;).</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th deficit will be changed to NDfct[ i ]. If nms == 0 (as the default), <em>all</em> the entries in the given range will be changed; if stp &gt; <a class="el" href="classMCFClass.html#a6438187f454e795c03a850bfab31be84" title="Return the number of nodes in the current graph. ">MCFn()</a>, then the smaller bound is used.</p>
<p>Note that, in <a class="el" href="classMCFClass.html#a50ee5aaf0f8b39a1edec078828ade458" title="Change the node deficits. ">ChgDfcts()</a>, node "names" (strt, stp or those contained in nms[]) go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit can be changed e.g. with ChgDfcts( &amp;new_deficit , 0 , 0 , 1 ).</p>
<dl class="section note"><dt>Note</dt><dd>changing the deficits of nodes that <em>do not exist</em> is <em>not allowed</em>; only nodes that have not been deleted [see <a class="el" href="classMCFClass.html#abecb8b32d512eea7daafba0e06ab4742" title="Delete the node name. ">DelNode()</a> below] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="a5ae235c4b587c8cffb777719c9221970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae235c4b587c8cffb777719c9221970">&#9670;&nbsp;</a></span>ChgDfct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgDfct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a>&#160;</td>
          <td class="paramname"><em>NDfct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the deficit of the i-th node. </p>
<p>Note that the node "name" i go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit can be changed e.g. with ChgDfcts( 0 , new_deficit ).</p>
<dl class="section note"><dt>Note</dt><dd>changing the deficits of nodes that <em>do not exist</em> is <em>not allowed</em>; only nodes that have not been deleted [see <a class="el" href="classMCFClass.html#abecb8b32d512eea7daafba0e06ab4742" title="Delete the node name. ">DelNode()</a> below] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="ae1c33ba491b57343fbc157123fff5b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c33ba491b57343fbc157123fff5b11">&#9670;&nbsp;</a></span>CloseArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CloseArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Close" the arc &lsquo;name&rsquo;. </p>
<p>Although all the associated information (name, cost, capacity, end and start node) is kept, the arc is removed from the problem until OpenArc( i ) [see below] is called.</p>
<p>"closed" arcs always have 0 flow, but are otherwise counted as any other arc; for instance, <a class="el" href="classMCFClass.html#ab4d5a0d0fc49882de0b4eb3146f1b7a6" title="Return the number of arcs in the current graph. ">MCFm()</a> does <em>not</em> decrease as an effect of a call to <a class="el" href="classMCFClass.html#ae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc name. ">CloseArc()</a>. How this closure is implemented is solver-specific. </p>

</div>
</div>
<a id="a2db08ae33bcdb997677a69f36c60c1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db08ae33bcdb997677a69f36c60c1e5">&#9670;&nbsp;</a></span>IsClosedArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsClosedArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classMCFClass.html#a2db08ae33bcdb997677a69f36c60c1e5" title="IsClosedArc() returns true if and only if the arc name is closed. ">IsClosedArc()</a> returns true if and only if the arc &lsquo;name&rsquo; is closed. </p>

</div>
</div>
<a id="abecb8b32d512eea7daafba0e06ab4742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecb8b32d512eea7daafba0e06ab4742">&#9670;&nbsp;</a></span>DelNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DelNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the node &lsquo;name&rsquo;. </p>
<p>For any value of &lsquo;name&rsquo;, all incident arcs to that node are closed [see <a class="el" href="classMCFClass.html#ae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc name. ">CloseArc()</a> above] (<em>not</em> Deleted, see <a class="el" href="classMCFClass.html#ae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc name. ">DelArc()</a> below) and the deficit is set to zero.</p>
<p>Il furthermore &lsquo;name&rsquo; is the last node, the number of nodes as reported by <a class="el" href="classMCFClass.html#a6438187f454e795c03a850bfab31be84" title="Return the number of nodes in the current graph. ">MCFn()</a> is reduced by at least one, until the n-th node is not a deleted one. </p>

</div>
</div>
<a id="ab902a23d1c9520a22b79de5d451c3348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab902a23d1c9520a22b79de5d451c3348">&#9670;&nbsp;</a></span>OpenArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OpenArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore the previously closed arc &lsquo;name&rsquo;. </p>
<p>It is an error to open an arc that has not been previously closed. </p>

</div>
</div>
<a id="a6d58679267d8b620cc3337583dab4626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d58679267d8b620cc3337583dab4626">&#9670;&nbsp;</a></span>AddNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> AddNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a>&#160;</td>
          <td class="paramname"><em>aDfct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new node with deficit aDfct, returning its name. </p>
<p>Inf&lt;Index&gt;() is returned if there is no room for a new node. Remember that the node names are either { 0 .. nmax - 1 } or { 1 .. nmax }, depending on the value of USENAME0. </p>

</div>
</div>
<a id="aef2d28b0b0a2420d6b8b7093d827fa67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2d28b0b0a2420d6b8b7093d827fa67">&#9670;&nbsp;</a></span>ChangeArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChangeArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>nSN</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>nEN</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the starting and/or ending node of arc &lsquo;name&rsquo; to nSN and nEN. </p>
<p>Each parameter being Inf&lt;Index&gt;() means to leave the previous starting or ending node untouched. When this method is called &lsquo;name&rsquo; can be either the name of a "normal" arc or that of a "closed" arc [see <a class="el" href="classMCFClass.html#ae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc name. ">CloseArc()</a> above]: in the latter case, at the end of <a class="el" href="classMCFClass.html#aef2d28b0b0a2420d6b8b7093d827fa67" title="Change the starting and/or ending node of arc name to nSN and nEN. ">ChangeArc()</a> the arc is <em>still closed</em>, and it remains so until OpenArc( name ) [see above] is called. </p>

</div>
</div>
<a id="ae291d6625ff31a5fdcc1ef166e2dee34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae291d6625ff31a5fdcc1ef166e2dee34">&#9670;&nbsp;</a></span>DelArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DelArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the arc &lsquo;name&rsquo;. </p>
<p>Unlike "closed" arcs, all the information associated with a deleted arc is lost and &lsquo;name&rsquo; is made available as a name for new arcs to be created with <a class="el" href="classMCFClass.html#a564d624f62ccc0c130d733cc5470cb6d" title="Add the new arc ( Start , End ) with cost aC and capacity aU, returning its name. ...">AddArc()</a> [see below].</p>
<p>Il furthermore &lsquo;name&rsquo; is the last arc, the number of arcs as reported by <a class="el" href="classMCFClass.html#ab4d5a0d0fc49882de0b4eb3146f1b7a6" title="Return the number of arcs in the current graph. ">MCFm()</a> is reduced by at least one, until the m-th arc is not a deleted one. Otherwise, the flow on the arc is always ensured to be 0. </p>

</div>
</div>
<a id="a5f72b1b728182519a6a11accdfa78c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f72b1b728182519a6a11accdfa78c7d">&#9670;&nbsp;</a></span>IsDeletedArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsDeletedArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if and only if the arc &lsquo;name&rsquo; is deleted. </p>
<p>It should only be called with name &lt; <a class="el" href="classMCFClass.html#ab4d5a0d0fc49882de0b4eb3146f1b7a6" title="Return the number of arcs in the current graph. ">MCFm()</a>, as every other arc is deleted by definition. </p>

</div>
</div>
<a id="a564d624f62ccc0c130d733cc5470cb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564d624f62ccc0c130d733cc5470cb6d">&#9670;&nbsp;</a></span>AddArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> AddArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a>&#160;</td>
          <td class="paramname"><em>aU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a>&#160;</td>
          <td class="paramname"><em>aC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the new arc ( Start , End ) with cost aC and capacity aU, returning its name. </p>
<p>Inf&lt;Index&gt;() is returned if there is no room for a new arc. Remember that arc names go from 0 to mmax - 1. </p>

</div>
</div>
<a id="aadaea79b7a516a86d9e318c31ce3d489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadaea79b7a516a86d9e318c31ce3d489">&#9670;&nbsp;</a></span>ETZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ETZ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if flow x is equal to zero (possibly considering tolerances). </p>

</div>
</div>
<a id="af314a8df7e38143854b9bf17c8eb25fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af314a8df7e38143854b9bf17c8eb25fc">&#9670;&nbsp;</a></span>GTZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GTZ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if flow x is greater than zero (possibly considering tolerances). </p>

</div>
</div>
<a id="ae414baaa6f224ce576574baa1e71650a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae414baaa6f224ce576574baa1e71650a">&#9670;&nbsp;</a></span>GEZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GEZ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if flow x is greater than or equal to zero (possibly considering tolerances). </p>

</div>
</div>
<a id="ab355a057db64a4b3da5209f747c01eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab355a057db64a4b3da5209f747c01eae">&#9670;&nbsp;</a></span>LTZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LTZ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if flow x is less than zero (possibly considering tolerances). </p>

</div>
</div>
<a id="adc1dfab25fba0d9badd0cce4dc99933b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1dfab25fba0d9badd0cce4dc99933b">&#9670;&nbsp;</a></span>LEZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LEZ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if flow x is less than or equal to zero (possibly considering tolerances). </p>

</div>
</div>
<a id="a7c0374fafa5efdfe1d78c22efaa9f9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0374fafa5efdfe1d78c22efaa9f9d6">&#9670;&nbsp;</a></span>LT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LT </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if flow x is less than flow y (possibly considering tolerances). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6e27f49150e9a14580fb313cc2777e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e27f49150e9a14580fb313cc2777e00">&#9670;&nbsp;</a></span>status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int status</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return status, see the comments to <a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be" title="Returns an int describing the current status of the MCF solver. ">MCFGetStatus()</a> above. </p>
<p>Note that the variable is defined int to allow derived classes to return their own specialized status codes </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classMCFClass.html">MCFClass</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
