<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The MCFClass Project: MCFClass Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The MCFClass Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classMCFClass__di__unipi__it_1_1MCFClass.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classMCFClass__di__unipi__it_1_1MCFClass-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MCFClass Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>This abstract base class defines a standard interface for (linear or convex quadartic separable) Min Cost Flow (MCF) problem solvers.  
 <a href="classMCFClass__di__unipi__it_1_1MCFClass.html#details">More...</a></p>

<p><code>#include &lt;MCFClass.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MCFClass:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMCFClass__di__unipi__it_1_1MCFClass.png" usemap="#MCFClass_map" alt=""/>
  <map id="MCFClass_map" name="MCFClass_map">
<area href="classMCFClass__di__unipi__it_1_1MCFCplex.html" title="The MCFCplex class derives from the abstract base class MCFClass, thus sharing its (standard) interfa..." alt="MCFCplex" shape="rect" coords="0,56,83,80"/>
<area href="classMCFClass__di__unipi__it_1_1MCFSimplex.html" title="The MCFSimplex class derives from the abstract base class MCFClass, thus sharing its (standard) inter..." alt="MCFSimplex" shape="rect" coords="93,56,176,80"/>
<area href="classMCFClass__di__unipi__it_1_1RelaxIV.html" title="The RelaxIV class derives from the abstract base class MCFClass, thus sharing its (standard) interfac..." alt="RelaxIV" shape="rect" coords="186,56,269,80"/>
<area href="classMCFClass__di__unipi__it_1_1SPTree.html" title="The SPTree class derives from the abstract base class MCFClass, thus sharing its (standard) interface..." alt="SPTree" shape="rect" coords="279,56,362,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass_1_1MCFException.html">MCFException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small class for exceptions.  <a href="classMCFClass__di__unipi__it_1_1MCFClass_1_1MCFException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass_1_1MCFState.html">MCFState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for representing the internal state of the MCF algorithm.  <a href="classMCFClass__di__unipi__it_1_1MCFClass_1_1MCFState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> defines four main public types:</p>
<ul>
<li>Index, the type of arc and node indices;</li>
<li>FNumber, the type of flow variables, arc capacities, and node deficits;</li>
<li>CNumber, the type of flow costs, node potentials, and arc reduced costs;</li>
<li>FONumber, the type of objective function value.</li>
</ul>
<p>By re-defining the types in this section, most MCFSolver should be made to work with any reasonable choice of data type (= one that is capable of properly representing the data of the instances to be solved). This may be relevant due to an important property of MCF problems: <em>if all arc capacities and node deficits are integer, then there exists an integral optimal primal solution</em>, and <em>if all arc costs are integer, then there exists an integral optimal dual solution</em>. Even more importantly, <em>many solution algorithms will in fact produce an integral primal/dual solution for free</em>, because <em>every primal/dual solution they generate during the solution process is naturally integral</em>. Therefore, one can use integer data types to represent everything connected with flows and/or costs if the corresponding data is integer in all instances one needs to solve. This directly translates in significant memory savings and/or speed improvements.</p>
<p>It is the user's responsibility to ensure that these types are set to reasonable values*. So, the experienced user may want to experiment with setting this data properly if memory footprint and/or speed is a primary concern. Note, however, that <em>not all solution algorithms will happily accept integer data</em>; one example are Interior-Point approaches, which require both flow and cost variables to be continuous (float). So, the viability of setting integer data (as well as its impact on performances) is strictly related to the specific kind of algorithm used. Since these types are common to all derived classes, they have to be set taking into account the needs of all the solvers that are going to be used, and adapting to the "worst case"; of course, FNumber == CNumber == double is going to always be an acceptable "worst case" setting. <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> may in a future be defined as a template class, with these as template parameters, but this is currently deemed overkill and avoided.</p>
<p>Finally, note that the above integrality property only holds for <em>linear</em> MCF problems. If any arc has a nonzero quadratic cost coefficient, optimal flows and potentials may be fractional even if all the data of the problem (comprised quadratic cost coefficients) is integer. Hence, for <em>quadratic</em> MCF solvers, a setting like FNumber == CNumber == double is actually mandatory*, for any reasonable algorithm will typically misbehave otherwise. </p>
</div></td></tr>
<tr class="memitem:af6e60cb841150361862d6b895c523e0a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0a">MCFParam</a> { <br />
&#160;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aab35d3e473676b56fa123d6df3d855aa0">kMaxTime</a> = 0
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa50d3edcd55bc1dd84d4e1719430f9d20">kMaxIter</a>
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa753a94f6a06a5579eb0855479dfbb6b1">kEpsFlw</a>
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa409d9ed5655d184667a5e486e5110c6e">kEpsDfct</a>
, <br />
&#160;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aaf263085cb23be60527c92896891cd12c">kEpsCst</a>
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa7efdbe01bec821f08a391f9542086475">kReopt</a>
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa99ac8339170db67bf9af4a60362ef7e1">kLastParam</a>
<br />
 }</td></tr>
<tr class="memdesc:af6e60cb841150361862d6b895c523e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public enum describing the possible parameters of the MCF solver, to be used with the methods <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a3b295ebd5b5519017af591da788885ae" title="set integer parameters of the algorithm">SetPar()</a> and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ac66ea95b63fe61ce67e0f8544f200887" title="returns one of the integer parameters of the algorithm">GetPar()</a>.  <a href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0a">More...</a><br /></td></tr>
<tr class="separator:af6e60cb841150361862d6b895c523e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ef269c5dd98eea5274eb03a3feb5fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fb">MCFStatus</a> { <br />
&#160;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1">kUnSolved</a> = -1
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fba42e6b26684acf67af002df88a9cf997c">kOK</a> = 0
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fba142714524ffdfe9cfebaa1033fd1a18f">kStopped</a>
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fba7db95dc60f32bc33a35f748f639cc6d0">kUnfeasible</a>
, <br />
&#160;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fba4b9de95ee3087851acd98262e09f0be8">kUnbounded</a>
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fbaacb2c04376333850bff6fb1065c0c171">kError</a>
<br />
 }</td></tr>
<tr class="memdesc:a15ef269c5dd98eea5274eb03a3feb5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public enum describing the possible status of the MCF solver.  <a href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fb">More...</a><br /></td></tr>
<tr class="separator:a15ef269c5dd98eea5274eb03a3feb5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b7f4459be059eae1a7d83a8e190c28"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28">MCFAnswer</a> { <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28a503f4e9dca6c8c12ea38f9e8c1be0126">kNo</a> = 0
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28ace5b3b5f2037b0d65d161b53b7c940fe">kYes</a>
 }</td></tr>
<tr class="memdesc:ad7b7f4459be059eae1a7d83a8e190c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public enum describing the possible reoptimization status of the MCF solver.  <a href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28">More...</a><br /></td></tr>
<tr class="separator:ad7b7f4459be059eae1a7d83a8e190c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1b139bac65f5f35bdadc7549a819de"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#adb1b139bac65f5f35bdadc7549a819de">MCFFlFrmt</a> { <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#adb1b139bac65f5f35bdadc7549a819dea6e65d07cdd719be7d99902bb47920a37">kDimacs</a> = 0
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#adb1b139bac65f5f35bdadc7549a819deac27a029d7010490d53e1df36b39597e6">kQDimacs</a>
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#adb1b139bac65f5f35bdadc7549a819dea65125719fd6c68bc3904a45937fcfd85">kMPS</a>
, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#adb1b139bac65f5f35bdadc7549a819dea7efb98d1b3dfca0f601d4df644b418a0">kFWMPS</a>
 }</td></tr>
<tr class="memdesc:adb1b139bac65f5f35bdadc7549a819de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public enum describing the possible file formats in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6afe6fc886cba0606b766cf14b3d4fca" title="write the current MCF problem to an ostream">WriteMCF()</a>.  <a href="classMCFClass__di__unipi__it_1_1MCFClass.html#adb1b139bac65f5f35bdadc7549a819de">More...</a><br /></td></tr>
<tr class="separator:adb1b139bac65f5f35bdadc7549a819de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="memItemLeft" align="right" valign="top"><a id="ad53d6229d7ec28555a9c9c2fd9abf773" name="ad53d6229d7ec28555a9c9c2fd9abf773"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>Index</b></td></tr>
<tr class="memdesc:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="mdescLeft">&#160;</td><td class="mdescRight">index of a node or arc ( &gt;= 0 ) <br /></td></tr>
<tr class="separator:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3388eb329ff0551a0b86b6c67e33d8"><td class="memItemLeft" align="right" valign="top"><a id="ace3388eb329ff0551a0b86b6c67e33d8" name="ace3388eb329ff0551a0b86b6c67e33d8"></a>
typedef <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Index_Set</b></td></tr>
<tr class="memdesc:ace3388eb329ff0551a0b86b6c67e33d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set (array) of indices <br /></td></tr>
<tr class="separator:ace3388eb329ff0551a0b86b6c67e33d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76aaabb20535c51a2752b93f6c38fe54"><td class="memItemLeft" align="right" valign="top"><a id="a76aaabb20535c51a2752b93f6c38fe54" name="a76aaabb20535c51a2752b93f6c38fe54"></a>
typedef const <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cIndex</b></td></tr>
<tr class="memdesc:a76aaabb20535c51a2752b93f6c38fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only index <br /></td></tr>
<tr class="separator:a76aaabb20535c51a2752b93f6c38fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81575b2d4e4d5636b17170432150ae69"><td class="memItemLeft" align="right" valign="top"><a id="a81575b2d4e4d5636b17170432150ae69" name="a81575b2d4e4d5636b17170432150ae69"></a>
typedef <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>cIndex_Set</b></td></tr>
<tr class="memdesc:a81575b2d4e4d5636b17170432150ae69"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only index array <br /></td></tr>
<tr class="separator:a81575b2d4e4d5636b17170432150ae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea3e5951d222b2a8e57de1b4246a909"><td class="memItemLeft" align="right" valign="top"><a id="aeea3e5951d222b2a8e57de1b4246a909" name="aeea3e5951d222b2a8e57de1b4246a909"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>FNumber</b></td></tr>
<tr class="memdesc:aeea3e5951d222b2a8e57de1b4246a909"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc flow <br /></td></tr>
<tr class="separator:aeea3e5951d222b2a8e57de1b4246a909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="memItemLeft" align="right" valign="top"><a id="a9dae1f1a39c208ce3c2b337cd5bb3d00" name="a9dae1f1a39c208ce3c2b337cd5bb3d00"></a>
typedef <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>FRow</b></td></tr>
<tr class="memdesc:a9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of flows <br /></td></tr>
<tr class="separator:a9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f747fbdff346237c8db4469d569994"><td class="memItemLeft" align="right" valign="top"><a id="a11f747fbdff346237c8db4469d569994" name="a11f747fbdff346237c8db4469d569994"></a>
typedef const <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cFNumber</b></td></tr>
<tr class="memdesc:a11f747fbdff346237c8db4469d569994"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only flow <br /></td></tr>
<tr class="separator:a11f747fbdff346237c8db4469d569994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad325f3193dbba0ddef1da4e72d29eda6"><td class="memItemLeft" align="right" valign="top"><a id="ad325f3193dbba0ddef1da4e72d29eda6" name="ad325f3193dbba0ddef1da4e72d29eda6"></a>
typedef <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>cFRow</b></td></tr>
<tr class="memdesc:ad325f3193dbba0ddef1da4e72d29eda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only flow array <br /></td></tr>
<tr class="separator:ad325f3193dbba0ddef1da4e72d29eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d0627ba8213afe1ec4ebeb4508e8f1"><td class="memItemLeft" align="right" valign="top"><a id="a24d0627ba8213afe1ec4ebeb4508e8f1" name="a24d0627ba8213afe1ec4ebeb4508e8f1"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>CNumber</b></td></tr>
<tr class="memdesc:a24d0627ba8213afe1ec4ebeb4508e8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc flow cost <br /></td></tr>
<tr class="separator:a24d0627ba8213afe1ec4ebeb4508e8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62409402be4e4b301e1a568f99f877be"><td class="memItemLeft" align="right" valign="top"><a id="a62409402be4e4b301e1a568f99f877be" name="a62409402be4e4b301e1a568f99f877be"></a>
typedef <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>CRow</b></td></tr>
<tr class="memdesc:a62409402be4e4b301e1a568f99f877be"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of costs <br /></td></tr>
<tr class="separator:a62409402be4e4b301e1a568f99f877be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dbefeeb08c3f63073622411893eb76"><td class="memItemLeft" align="right" valign="top"><a id="a07dbefeeb08c3f63073622411893eb76" name="a07dbefeeb08c3f63073622411893eb76"></a>
typedef const <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cCNumber</b></td></tr>
<tr class="memdesc:a07dbefeeb08c3f63073622411893eb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only cost <br /></td></tr>
<tr class="separator:a07dbefeeb08c3f63073622411893eb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab700102e9ba8bb6015be6818d4e99097"><td class="memItemLeft" align="right" valign="top"><a id="ab700102e9ba8bb6015be6818d4e99097" name="ab700102e9ba8bb6015be6818d4e99097"></a>
typedef <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>cCRow</b></td></tr>
<tr class="memdesc:ab700102e9ba8bb6015be6818d4e99097"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only cost array <br /></td></tr>
<tr class="separator:ab700102e9ba8bb6015be6818d4e99097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ee7b3099b0bc780a6a4b43629488fa"><td class="memItemLeft" align="right" valign="top"><a id="af5ee7b3099b0bc780a6a4b43629488fa" name="af5ee7b3099b0bc780a6a4b43629488fa"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>FONumber</b></td></tr>
<tr class="memdesc:af5ee7b3099b0bc780a6a4b43629488fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the objective function: has to hold sums of products of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909" title="type of arc flow">FNumber(s)</a> by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1" title="type of arc flow cost">CNumber(s)</a> <br /></td></tr>
<tr class="separator:af5ee7b3099b0bc780a6a4b43629488fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7942d00ff59c58e29834ecb27d8efe0"><td class="memItemLeft" align="right" valign="top"><a id="ac7942d00ff59c58e29834ecb27d8efe0" name="ac7942d00ff59c58e29834ecb27d8efe0"></a>
typedef const <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cFONumber</b></td></tr>
<tr class="memdesc:ac7942d00ff59c58e29834ecb27d8efe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only o.f. value <br /></td></tr>
<tr class="separator:ac7942d00ff59c58e29834ecb27d8efe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab547218814e3b90d15f219f5aaf8b937"><td class="memItemLeft" align="right" valign="top"><a id="ab547218814e3b90d15f219f5aaf8b937" name="ab547218814e3b90d15f219f5aaf8b937"></a>
typedef <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass_1_1MCFState.html">MCFState</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>MCFStatePtr</b></td></tr>
<tr class="memdesc:ab547218814e3b90d15f219f5aaf8b937"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to a <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass_1_1MCFState.html" title="Base class for representing the internal state of the MCF algorithm.">MCFState</a> <br /></td></tr>
<tr class="separator:ab547218814e3b90d15f219f5aaf8b937"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a52812a5637b5bef5b6168f7bd062aa86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a52812a5637b5bef5b6168f7bd062aa86">MCFClass</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> nmx=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> mmx=0)</td></tr>
<tr class="memdesc:a52812a5637b5bef5b6168f7bd062aa86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <br /></td></tr>
<tr class="separator:a52812a5637b5bef5b6168f7bd062aa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other initializations</div></td></tr>
<tr class="memitem:aa55a46d5b60df521c30da61e222f6da9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9">LoadNet</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> nmx=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> mmx=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> pn=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> pm=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> pU=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> pC=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> pDfct=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> pSn=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> pEn=0)=0</td></tr>
<tr class="memdesc:aa55a46d5b60df521c30da61e222f6da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">inputs a new network from memory  <br /></td></tr>
<tr class="separator:aa55a46d5b60df521c30da61e222f6da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d79a2f00cf8a2416b2b3e41552e843"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a34d79a2f00cf8a2416b2b3e41552e843">LoadDMX</a> (istream &amp;DMXs, bool IsQuad=false)</td></tr>
<tr class="memdesc:a34d79a2f00cf8a2416b2b3e41552e843"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a MCF instance from a stream  <br /></td></tr>
<tr class="separator:a34d79a2f00cf8a2416b2b3e41552e843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0554708d9abb0e079a8d6f073def9bab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a0554708d9abb0e079a8d6f073def9bab">PreProcess</a> (void)</td></tr>
<tr class="memdesc:a0554708d9abb0e079a8d6f073def9bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">pre-process the instamce  <br /></td></tr>
<tr class="separator:a0554708d9abb0e079a8d6f073def9bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b295ebd5b5519017af591da788885ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a3b295ebd5b5519017af591da788885ae">SetPar</a> (int par, int val)</td></tr>
<tr class="memdesc:a3b295ebd5b5519017af591da788885ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">set integer parameters of the algorithm  <br /></td></tr>
<tr class="separator:a3b295ebd5b5519017af591da788885ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1efc4bd7bee3a0cf9366536feb463a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1d1efc4bd7bee3a0cf9366536feb463a">SetPar</a> (int par, double val)</td></tr>
<tr class="memdesc:a1d1efc4bd7bee3a0cf9366536feb463a"><td class="mdescLeft">&#160;</td><td class="mdescRight">set float parameters of the algorithm.  <br /></td></tr>
<tr class="separator:a1d1efc4bd7bee3a0cf9366536feb463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66ea95b63fe61ce67e0f8544f200887"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ac66ea95b63fe61ce67e0f8544f200887">GetPar</a> (int par, int &amp;val) const</td></tr>
<tr class="memdesc:ac66ea95b63fe61ce67e0f8544f200887"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns one of the integer parameters of the algorithm  <br /></td></tr>
<tr class="separator:ac66ea95b63fe61ce67e0f8544f200887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677caf4176eef1509a0fdf87c0662897"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a677caf4176eef1509a0fdf87c0662897">GetPar</a> (int par, double &amp;val) const</td></tr>
<tr class="memdesc:a677caf4176eef1509a0fdf87c0662897"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns one of the double parameters of the algorithm  <br /></td></tr>
<tr class="separator:a677caf4176eef1509a0fdf87c0662897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5441232979a0ac98410d765b04830eeb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a5441232979a0ac98410d765b04830eeb">SetMCFTime</a> (bool TimeIt=true)</td></tr>
<tr class="memdesc:a5441232979a0ac98410d765b04830eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the timer of the code  <br /></td></tr>
<tr class="separator:a5441232979a0ac98410d765b04830eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Solving the problem</div></td></tr>
<tr class="memitem:ac0d96429d896a2d878a5f057535ab1ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ac0d96429d896a2d878a5f057535ab1ee">SolveMCF</a> (void)=0</td></tr>
<tr class="memdesc:ac0d96429d896a2d878a5f057535ab1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve the problem  <br /></td></tr>
<tr class="separator:ac0d96429d896a2d878a5f057535ab1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03701bebeaaf83d06f9d42a84ab92fd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8">MCFGetStatus</a> (void) const</td></tr>
<tr class="memdesc:a03701bebeaaf83d06f9d42a84ab92fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the solution status  <br /></td></tr>
<tr class="separator:a03701bebeaaf83d06f9d42a84ab92fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading flow solution</div></td></tr>
<tr class="memitem:abbddb4d3d6e3ec68f849d64618de037d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#abbddb4d3d6e3ec68f849d64618de037d">MCFGetX</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> F, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> nms=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;()) const =0</td></tr>
<tr class="memdesc:abbddb4d3d6e3ec68f849d64618de037d"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the optimal flow solution in a vector  <br /></td></tr>
<tr class="separator:abbddb4d3d6e3ec68f849d64618de037d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b0e00ff4baafb00ff03e213ca83dbd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a76b0e00ff4baafb00ff03e213ca83dbd">MCFGetX</a> (void) const</td></tr>
<tr class="memdesc:a76b0e00ff4baafb00ff03e213ca83dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a read-only pointer to the flow solution  <br /></td></tr>
<tr class="separator:a76b0e00ff4baafb00ff03e213ca83dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4966a98c7ffa909057064beb4507a5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7a4966a98c7ffa909057064beb4507a5">HaveNewX</a> (void)</td></tr>
<tr class="memdesc:a7a4966a98c7ffa909057064beb4507a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">tells if a different flow solution is available  <br /></td></tr>
<tr class="separator:a7a4966a98c7ffa909057064beb4507a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading the dual solution</div></td></tr>
<tr class="memitem:a699c8adb373a2d8804c6d56c8b29b3f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a699c8adb373a2d8804c6d56c8b29b3f1">MCFGetPi</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> P, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;()) const =0</td></tr>
<tr class="memdesc:a699c8adb373a2d8804c6d56c8b29b3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes the optimal node potentials in a vector  <br /></td></tr>
<tr class="separator:a699c8adb373a2d8804c6d56c8b29b3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9589c18168466325844bc8d43ab60518"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9589c18168466325844bc8d43ab60518">MCFGetPi</a> (void) const</td></tr>
<tr class="memdesc:a9589c18168466325844bc8d43ab60518"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a read-only pointer to the node potentials  <br /></td></tr>
<tr class="separator:a9589c18168466325844bc8d43ab60518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b2b6516a7874ac55145312bd2d55bb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87b2b6516a7874ac55145312bd2d55bb">HaveNewPi</a> (void)</td></tr>
<tr class="memdesc:a87b2b6516a7874ac55145312bd2d55bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">tells if a different dual solution is available  <br /></td></tr>
<tr class="separator:a87b2b6516a7874ac55145312bd2d55bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5426e6d07ed8bf6328aad9c256e5c602"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a5426e6d07ed8bf6328aad9c256e5c602">MCFGetRC</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> CR, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;()) const =0</td></tr>
<tr class="memdesc:a5426e6d07ed8bf6328aad9c256e5c602"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the reduced costs in a vector  <br /></td></tr>
<tr class="separator:a5426e6d07ed8bf6328aad9c256e5c602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9fe72baa305e432331d4f7e98f6b2c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aef9fe72baa305e432331d4f7e98f6b2c">MCFGetRC</a> (void) const</td></tr>
<tr class="memdesc:aef9fe72baa305e432331d4f7e98f6b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a read-only pointer to an the reduced costs  <br /></td></tr>
<tr class="separator:aef9fe72baa305e432331d4f7e98f6b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34bf85e8dd62d8940581130f5a2b9ed"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa34bf85e8dd62d8940581130f5a2b9ed">MCFGetRC</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> i) const =0</td></tr>
<tr class="memdesc:aa34bf85e8dd62d8940581130f5a2b9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the reduced cost of the i-th arc  <br /></td></tr>
<tr class="separator:aa34bf85e8dd62d8940581130f5a2b9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading the objective function value</div></td></tr>
<tr class="memitem:a8fa24610af25b480e674fd71aa941ecd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8fa24610af25b480e674fd71aa941ecd">MCFGetFO</a> (void) const =0</td></tr>
<tr class="memdesc:a8fa24610af25b480e674fd71aa941ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the objective function value of the primal solution  <br /></td></tr>
<tr class="separator:a8fa24610af25b480e674fd71aa941ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bfb9cbd09a1f0851627169103e92a2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af1bfb9cbd09a1f0851627169103e92a2">MCFGetDFO</a> (void) const</td></tr>
<tr class="memdesc:af1bfb9cbd09a1f0851627169103e92a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the objective function value of the dual solution  <br /></td></tr>
<tr class="separator:af1bfb9cbd09a1f0851627169103e92a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getting unfeasibility / unboundedness certificates</div></td></tr>
<tr class="memitem:a7eb96eea797b718349097ed6dc6aaab1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7eb96eea797b718349097ed6dc6aaab1">MCFGetUnfCut</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Cut) const</td></tr>
<tr class="memdesc:a7eb96eea797b718349097ed6dc6aaab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an unfeasibility certificate  <br /></td></tr>
<tr class="separator:a7eb96eea797b718349097ed6dc6aaab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe7f2953cd36ea8efe5790d071ca65c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aafe7f2953cd36ea8efe5790d071ca65c">MCFGetUnbCycl</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Pred, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> ArcPred) const</td></tr>
<tr class="memdesc:aafe7f2953cd36ea8efe5790d071ca65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an unboundedness certificate  <br /></td></tr>
<tr class="separator:aafe7f2953cd36ea8efe5790d071ca65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Saving/restoring the state of the solver</div></td></tr>
<tr class="memitem:ae7465ca4be416c7bd49d496d86ccba46"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ae7465ca4be416c7bd49d496d86ccba46">MCFGetState</a> (void) const</td></tr>
<tr class="memdesc:ae7465ca4be416c7bd49d496d86ccba46"><td class="mdescLeft">&#160;</td><td class="mdescRight">save the state of the MCF solver  <br /></td></tr>
<tr class="separator:ae7465ca4be416c7bd49d496d86ccba46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14589cd80aed231b6fc7da247f50601"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ac14589cd80aed231b6fc7da247f50601">MCFPutState</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a> S)</td></tr>
<tr class="memdesc:ac14589cd80aed231b6fc7da247f50601"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore the state of the solver  <br /></td></tr>
<tr class="separator:ac14589cd80aed231b6fc7da247f50601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Time the code</div></td></tr>
<tr class="memitem:ae30b2377d5464d44b234bcc44ceb2a6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ae30b2377d5464d44b234bcc44ceb2a6f">TimeMCF</a> (double &amp;t_us, double &amp;t_ss) const</td></tr>
<tr class="memdesc:ae30b2377d5464d44b234bcc44ceb2a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">time the code  <br /></td></tr>
<tr class="separator:ae30b2377d5464d44b234bcc44ceb2a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c950787358582eb9038bd8f9dcfb070"><td class="memItemLeft" align="right" valign="top"><a id="a0c950787358582eb9038bd8f9dcfb070" name="a0c950787358582eb9038bd8f9dcfb070"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>TimeMCF</b> (void) const</td></tr>
<tr class="memdesc:a0c950787358582eb9038bd8f9dcfb070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like TimeMCF( double , double ) [see above], but returns the total time. <br /></td></tr>
<tr class="separator:a0c950787358582eb9038bd8f9dcfb070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Check the solutions</div></td></tr>
<tr class="memitem:a7c8357e94656cea56777203f7d4345b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7c8357e94656cea56777203f7d4345b2">CheckPSol</a> (void) const</td></tr>
<tr class="memdesc:a7c8357e94656cea56777203f7d4345b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks the primal solution  <br /></td></tr>
<tr class="separator:a7c8357e94656cea56777203f7d4345b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f68e5fc8390d9fa6e4c1ff6552df0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87f68e5fc8390d9fa6e4c1ff6552df0c">CheckDSol</a> (void) const</td></tr>
<tr class="memdesc:a87f68e5fc8390d9fa6e4c1ff6552df0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks the dual solution  <br /></td></tr>
<tr class="separator:a87f68e5fc8390d9fa6e4c1ff6552df0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading graph size and topology</div></td></tr>
<tr class="memitem:a4630f116b2dc9f80359df6e4ef9649ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a4630f116b2dc9f80359df6e4ef9649ca">MCFnmax</a> (void) const</td></tr>
<tr class="memdesc:a4630f116b2dc9f80359df6e4ef9649ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximum number of nodes  <br /></td></tr>
<tr class="separator:a4630f116b2dc9f80359df6e4ef9649ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139c737142980169abf4179c1a1dee25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a139c737142980169abf4179c1a1dee25">MCFmmax</a> (void) const</td></tr>
<tr class="memdesc:a139c737142980169abf4179c1a1dee25"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximum number of arcs  <br /></td></tr>
<tr class="separator:a139c737142980169abf4179c1a1dee25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa06580ba205fe81a2032afa980da82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1aa06580ba205fe81a2032afa980da82">MCFn</a> (void) const</td></tr>
<tr class="memdesc:a1aa06580ba205fe81a2032afa980da82"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the current number of nodes  <br /></td></tr>
<tr class="separator:a1aa06580ba205fe81a2032afa980da82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572d5627356cb68d1dc654d0da000c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82">MCFm</a> (void) const</td></tr>
<tr class="memdesc:a572d5627356cb68d1dc654d0da000c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the current number of arcs  <br /></td></tr>
<tr class="separator:a572d5627356cb68d1dc654d0da000c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2830a07595970284ee05117c621abfc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa2830a07595970284ee05117c621abfc">MCFArcs</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Startv, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Endv, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;()) const =0</td></tr>
<tr class="memdesc:aa2830a07595970284ee05117c621abfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the starting and ending nodes in vectors  <br /></td></tr>
<tr class="separator:aa2830a07595970284ee05117c621abfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a89759c70e6df8a37ad7d915fd873bc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a4a89759c70e6df8a37ad7d915fd873bc">MCFSNde</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> i) const =0</td></tr>
<tr class="memdesc:a4a89759c70e6df8a37ad7d915fd873bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the starting (tail) node of the arc &lsquo;i&rsquo;  <br /></td></tr>
<tr class="separator:a4a89759c70e6df8a37ad7d915fd873bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321ee5226247ff7f16e93b5e2e55a4dd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a321ee5226247ff7f16e93b5e2e55a4dd">MCFENde</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> i) const =0</td></tr>
<tr class="memdesc:a321ee5226247ff7f16e93b5e2e55a4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the ending (head) node of the arc &lsquo;i&rsquo;  <br /></td></tr>
<tr class="separator:a321ee5226247ff7f16e93b5e2e55a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6584ec304a6ee6c9ff057e4f83bf6651"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6584ec304a6ee6c9ff057e4f83bf6651">MCFSNdes</a> (void) const</td></tr>
<tr class="memdesc:a6584ec304a6ee6c9ff057e4f83bf6651"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a read-only pointer to the vector of starting nodes  <br /></td></tr>
<tr class="separator:a6584ec304a6ee6c9ff057e4f83bf6651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fe0ee1951e62add38185a24f6fe719"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a53fe0ee1951e62add38185a24f6fe719">MCFENdes</a> (void) const</td></tr>
<tr class="memdesc:a53fe0ee1951e62add38185a24f6fe719"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a read-only pointer to the vector of ending nodes  <br /></td></tr>
<tr class="separator:a53fe0ee1951e62add38185a24f6fe719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading arc costs / capacities</div></td></tr>
<tr class="memitem:aeaaded5485711ad33d95376a97eb55c7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeaaded5485711ad33d95376a97eb55c7">MCFCosts</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> Costv, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;()) const =0</td></tr>
<tr class="memdesc:aeaaded5485711ad33d95376a97eb55c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the arc costs into a vector  <br /></td></tr>
<tr class="separator:aeaaded5485711ad33d95376a97eb55c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e34001e506e91ae6f8f1609afb8cfa0"><td class="memItemLeft" align="right" valign="top"><a id="a6e34001e506e91ae6f8f1609afb8cfa0" name="a6e34001e506e91ae6f8f1609afb8cfa0"></a>
virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MCFCost</b> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> i) const =0</td></tr>
<tr class="memdesc:a6e34001e506e91ae6f8f1609afb8cfa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the cost of the i-th arc <br /></td></tr>
<tr class="separator:a6e34001e506e91ae6f8f1609afb8cfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9beabbcc03bc333ba2ec0e0072e4dfb3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9beabbcc03bc333ba2ec0e0072e4dfb3">MCFCosts</a> (void) const</td></tr>
<tr class="memdesc:a9beabbcc03bc333ba2ec0e0072e4dfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a read-only pointer to the vector of arc costs  <br /></td></tr>
<tr class="separator:a9beabbcc03bc333ba2ec0e0072e4dfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd114e9f6e70cb2a0dc4259af4d0d9f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#abdd114e9f6e70cb2a0dc4259af4d0d9f">MCFQCoef</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> Qv, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;()) const</td></tr>
<tr class="memdesc:abdd114e9f6e70cb2a0dc4259af4d0d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the quadratic coefficients of the arc costs into a vector  <br /></td></tr>
<tr class="separator:abdd114e9f6e70cb2a0dc4259af4d0d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54237130edd37b17ad9032b8b85ac7e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af54237130edd37b17ad9032b8b85ac7e">MCFQCoef</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> i) const</td></tr>
<tr class="memdesc:af54237130edd37b17ad9032b8b85ac7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the quadratic coefficients of the cost of the i-th arc  <br /></td></tr>
<tr class="separator:af54237130edd37b17ad9032b8b85ac7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe2e1c0ed569cdcac2ea817c9e15db6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a0fe2e1c0ed569cdcac2ea817c9e15db6">MCFQCoef</a> (void) const</td></tr>
<tr class="memdesc:a0fe2e1c0ed569cdcac2ea817c9e15db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a read-only pointer to the vector of arc quadratic costs  <br /></td></tr>
<tr class="separator:a0fe2e1c0ed569cdcac2ea817c9e15db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa36d21d8df9e1d85849ab796d4b9ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#acaa36d21d8df9e1d85849ab796d4b9ca">MCFUCaps</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> UCapv, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;()) const =0</td></tr>
<tr class="memdesc:acaa36d21d8df9e1d85849ab796d4b9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the arc capacities into a vector  <br /></td></tr>
<tr class="separator:acaa36d21d8df9e1d85849ab796d4b9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb7ef61fd8db9082b46b938bd0c35ed"><td class="memItemLeft" align="right" valign="top"><a id="a7cb7ef61fd8db9082b46b938bd0c35ed" name="a7cb7ef61fd8db9082b46b938bd0c35ed"></a>
virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MCFUCap</b> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> i) const =0</td></tr>
<tr class="memdesc:a7cb7ef61fd8db9082b46b938bd0c35ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the capacity of the i-th arc <br /></td></tr>
<tr class="separator:a7cb7ef61fd8db9082b46b938bd0c35ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0781725626c581e345cfb2354ca48b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#afd0781725626c581e345cfb2354ca48b">MCFUCaps</a> (void) const</td></tr>
<tr class="memdesc:afd0781725626c581e345cfb2354ca48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a read-only pointer to an the vector of arc capacities  <br /></td></tr>
<tr class="separator:afd0781725626c581e345cfb2354ca48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading node deficits</div></td></tr>
<tr class="memitem:a4c6c9bad12327221a39f9ed312f7958b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a4c6c9bad12327221a39f9ed312f7958b">MCFDfcts</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> Dfctv, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;()) const =0</td></tr>
<tr class="memdesc:a4c6c9bad12327221a39f9ed312f7958b"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the node deficits into a vector  <br /></td></tr>
<tr class="separator:a4c6c9bad12327221a39f9ed312f7958b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6b79b9254d345c15b83ac30885fd3e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aae6b79b9254d345c15b83ac30885fd3e">MCFDfct</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> i) const =0</td></tr>
<tr class="memdesc:aae6b79b9254d345c15b83ac30885fd3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the deficit of the i-th node  <br /></td></tr>
<tr class="separator:aae6b79b9254d345c15b83ac30885fd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab069987c4ba513e98364780e8807f739"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab069987c4ba513e98364780e8807f739">MCFDfcts</a> (void) const</td></tr>
<tr class="memdesc:ab069987c4ba513e98364780e8807f739"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a read-only pointer to the vector of node deficits  <br /></td></tr>
<tr class="separator:ab069987c4ba513e98364780e8807f739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Write problem to file</div></td></tr>
<tr class="memitem:a6afe6fc886cba0606b766cf14b3d4fca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6afe6fc886cba0606b766cf14b3d4fca">WriteMCF</a> (ostream &amp;oStrm, int frmt=0) const</td></tr>
<tr class="memdesc:a6afe6fc886cba0606b766cf14b3d4fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the current MCF problem to an ostream  <br /></td></tr>
<tr class="separator:a6afe6fc886cba0606b766cf14b3d4fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Changing the arc costs / capacities</div></td></tr>
<tr class="memitem:a9d8aca3dbd796c03525e503a8aaa71bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9d8aca3dbd796c03525e503a8aaa71bb">ChgCosts</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> NCost, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a9d8aca3dbd796c03525e503a8aaa71bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the arc costs  <br /></td></tr>
<tr class="separator:a9d8aca3dbd796c03525e503a8aaa71bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac731ea9479f870dca111ba07a6d58a3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ac731ea9479f870dca111ba07a6d58a3f">ChgCost</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> arc, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> NCost)=0</td></tr>
<tr class="memdesc:ac731ea9479f870dca111ba07a6d58a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the cost of the i-th arc  <br /></td></tr>
<tr class="separator:ac731ea9479f870dca111ba07a6d58a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a55e6b1dda20d5835b0a162f80463ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1a55e6b1dda20d5835b0a162f80463ac">ChgQCoef</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> NQCoef=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="memdesc:a1a55e6b1dda20d5835b0a162f80463ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the quadratic coefficients of the arc costs  <br /></td></tr>
<tr class="separator:a1a55e6b1dda20d5835b0a162f80463ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab378af205999614b6d92612b005f4189"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab378af205999614b6d92612b005f4189">ChgQCoef</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> arc, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> NQCoef)</td></tr>
<tr class="memdesc:ab378af205999614b6d92612b005f4189"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the quadratic coefficient of the cost of the i-th arc  <br /></td></tr>
<tr class="separator:ab378af205999614b6d92612b005f4189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab838755daac0e0355e872f996f8cc0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aab838755daac0e0355e872f996f8cc0d">ChgUCaps</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> NCap, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:aab838755daac0e0355e872f996f8cc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the arc capacities  <br /></td></tr>
<tr class="separator:aab838755daac0e0355e872f996f8cc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdb302f0b1350bb545420c18752839a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#abfdb302f0b1350bb545420c18752839a">ChgUCap</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> arc, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> NCap)=0</td></tr>
<tr class="memdesc:abfdb302f0b1350bb545420c18752839a"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the capacity of the i-th arc  <br /></td></tr>
<tr class="separator:abfdb302f0b1350bb545420c18752839a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Changing the node deficits</div></td></tr>
<tr class="memitem:a3fe9ca77701d03d772fcaf0c5817ded3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a3fe9ca77701d03d772fcaf0c5817ded3">ChgDfcts</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> NDfct, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a3fe9ca77701d03d772fcaf0c5817ded3"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the node deficits  <br /></td></tr>
<tr class="separator:a3fe9ca77701d03d772fcaf0c5817ded3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4512c7e365110863c5ef90854ceebfdc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a4512c7e365110863c5ef90854ceebfdc">ChgDfct</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> node, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> NDfct)=0</td></tr>
<tr class="memdesc:a4512c7e365110863c5ef90854ceebfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the deficit of the i-th node  <br /></td></tr>
<tr class="separator:a4512c7e365110863c5ef90854ceebfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Changing graph topology</div></td></tr>
<tr class="memitem:aa71f643926bec5b0634f66d112704205"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa71f643926bec5b0634f66d112704205">CloseArc</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> name)=0</td></tr>
<tr class="memdesc:aa71f643926bec5b0634f66d112704205"><td class="mdescLeft">&#160;</td><td class="mdescRight">"close" one arc  <br /></td></tr>
<tr class="separator:aa71f643926bec5b0634f66d112704205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a46e52b3d48c27536b745750e82dd6"><td class="memItemLeft" align="right" valign="top"><a id="a90a46e52b3d48c27536b745750e82dd6" name="a90a46e52b3d48c27536b745750e82dd6"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsClosedArc</b> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> name) const =0</td></tr>
<tr class="memdesc:a90a46e52b3d48c27536b745750e82dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if and only if the arc &lsquo;name&rsquo; is closed <br /></td></tr>
<tr class="separator:a90a46e52b3d48c27536b745750e82dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e935c4f233322c893e1e3630b70f465"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a4e935c4f233322c893e1e3630b70f465">DelNode</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> name)=0</td></tr>
<tr class="memdesc:a4e935c4f233322c893e1e3630b70f465"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete one node  <br /></td></tr>
<tr class="separator:a4e935c4f233322c893e1e3630b70f465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6eb03b7e44dbc8b8b845ac3fa7632a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8e6eb03b7e44dbc8b8b845ac3fa7632a">OpenArc</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> name)=0</td></tr>
<tr class="memdesc:a8e6eb03b7e44dbc8b8b845ac3fa7632a"><td class="mdescLeft">&#160;</td><td class="mdescRight">re-opens a closed arc  <br /></td></tr>
<tr class="separator:a8e6eb03b7e44dbc8b8b845ac3fa7632a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b39d6d4a8938d7ea99dd9d6ef173422"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a3b39d6d4a8938d7ea99dd9d6ef173422">AddNode</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> aDfct)=0</td></tr>
<tr class="memdesc:a3b39d6d4a8938d7ea99dd9d6ef173422"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a ned node  <br /></td></tr>
<tr class="separator:a3b39d6d4a8938d7ea99dd9d6ef173422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab644a7aaaf652ee7dfc372831d10ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aaab644a7aaaf652ee7dfc372831d10ce">ChangeArc</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> name, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> nSN=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;(), <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> nEN=Inf&lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:aaab644a7aaaf652ee7dfc372831d10ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the starting and/or ending node of one arc  <br /></td></tr>
<tr class="separator:aaab644a7aaaf652ee7dfc372831d10ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7de6dac2b157eef88ea0bc55bc1f887"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa7de6dac2b157eef88ea0bc55bc1f887">DelArc</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> name)=0</td></tr>
<tr class="memdesc:aa7de6dac2b157eef88ea0bc55bc1f887"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes one arc  <br /></td></tr>
<tr class="separator:aa7de6dac2b157eef88ea0bc55bc1f887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7682b19c9163c24d66af23071791de64"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7682b19c9163c24d66af23071791de64">IsDeletedArc</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> name) const =0</td></tr>
<tr class="memdesc:a7682b19c9163c24d66af23071791de64"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if and only if the arc is deleted  <br /></td></tr>
<tr class="separator:a7682b19c9163c24d66af23071791de64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edfad62b2d73be9e079fc521fff0c1b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a0edfad62b2d73be9e079fc521fff0c1b">AddArc</a> (<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> Start, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> End, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> aU, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> aC)=0</td></tr>
<tr class="memdesc:a0edfad62b2d73be9e079fc521fff0c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a new arc  <br /></td></tr>
<tr class="separator:a0edfad62b2d73be9e079fc521fff0c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a93c0882740d38b9f8eb05994a01f76b7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a93c0882740d38b9f8eb05994a01f76b7">~MCFClass</a> ()</td></tr>
<tr class="memdesc:a93c0882740d38b9f8eb05994a01f76b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor of the class  <br /></td></tr>
<tr class="separator:a93c0882740d38b9f8eb05994a01f76b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Managing comparisons.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The following methods are provided for making it easier to perform comparisons, with and without tolerances. </p>
</div></td></tr>
<tr class="memitem:a260ef7a8885fdffab5638a8200a6ee11"><td class="memTemplParams" colspan="2"><a id="a260ef7a8885fdffab5638a8200a6ee11" name="a260ef7a8885fdffab5638a8200a6ee11"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a260ef7a8885fdffab5638a8200a6ee11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ETZ</b> (T x, T eps) const</td></tr>
<tr class="memdesc:a260ef7a8885fdffab5638a8200a6ee11"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is equal to zero (possibly considering tolerances). <br /></td></tr>
<tr class="separator:a260ef7a8885fdffab5638a8200a6ee11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44ede948e50793bc69c9ce50e3ff862"><td class="memTemplParams" colspan="2"><a id="aa44ede948e50793bc69c9ce50e3ff862" name="aa44ede948e50793bc69c9ce50e3ff862"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa44ede948e50793bc69c9ce50e3ff862"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GTZ</b> (T x, T eps) const</td></tr>
<tr class="memdesc:aa44ede948e50793bc69c9ce50e3ff862"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is greater than zero (possibly considering tolerances). <br /></td></tr>
<tr class="separator:aa44ede948e50793bc69c9ce50e3ff862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcbf069cec0d2f207d440045f5266b9"><td class="memTemplParams" colspan="2"><a id="affcbf069cec0d2f207d440045f5266b9" name="affcbf069cec0d2f207d440045f5266b9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:affcbf069cec0d2f207d440045f5266b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GEZ</b> (T x, T eps) const</td></tr>
<tr class="memdesc:affcbf069cec0d2f207d440045f5266b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is greater than or equal to zero (possibly considering tolerances). <br /></td></tr>
<tr class="separator:affcbf069cec0d2f207d440045f5266b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabd37f04b963a582caeb36966f8affd"><td class="memTemplParams" colspan="2"><a id="acabd37f04b963a582caeb36966f8affd" name="acabd37f04b963a582caeb36966f8affd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acabd37f04b963a582caeb36966f8affd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LTZ</b> (T x, T eps) const</td></tr>
<tr class="memdesc:acabd37f04b963a582caeb36966f8affd"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is less than zero (possibly considering tolerances). <br /></td></tr>
<tr class="separator:acabd37f04b963a582caeb36966f8affd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39245e4b216d1092a2361db6112fad8e"><td class="memTemplParams" colspan="2"><a id="a39245e4b216d1092a2361db6112fad8e" name="a39245e4b216d1092a2361db6112fad8e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a39245e4b216d1092a2361db6112fad8e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LEZ</b> (T x, T eps) const</td></tr>
<tr class="memdesc:a39245e4b216d1092a2361db6112fad8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is less than or equal to zero (possibly considering tolerances). <br /></td></tr>
<tr class="separator:a39245e4b216d1092a2361db6112fad8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4497a2714ac9b23506c1beacfb9e32"><td class="memTemplParams" colspan="2"><a id="aac4497a2714ac9b23506c1beacfb9e32" name="aac4497a2714ac9b23506c1beacfb9e32"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aac4497a2714ac9b23506c1beacfb9e32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GT</b> (T x, T y, T eps) const</td></tr>
<tr class="memdesc:aac4497a2714ac9b23506c1beacfb9e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is greater than flow y (possibly considering tolerances). <br /></td></tr>
<tr class="separator:aac4497a2714ac9b23506c1beacfb9e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef480b236190ea4dc5350ba0a41af10b"><td class="memTemplParams" colspan="2"><a id="aef480b236190ea4dc5350ba0a41af10b" name="aef480b236190ea4dc5350ba0a41af10b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aef480b236190ea4dc5350ba0a41af10b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LT</b> (T x, T y, T eps) const</td></tr>
<tr class="memdesc:aef480b236190ea4dc5350ba0a41af10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is less than flow y (possibly considering tolerances). <br /></td></tr>
<tr class="separator:aef480b236190ea4dc5350ba0a41af10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7f0f8bcc88c30609d766a4e723a53dac"><td class="memItemLeft" align="right" valign="top"><a id="a7f0f8bcc88c30609d766a4e723a53dac" name="a7f0f8bcc88c30609d766a4e723a53dac"></a>
<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>n</b></td></tr>
<tr class="memdesc:a7f0f8bcc88c30609d766a4e723a53dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of nodes <br /></td></tr>
<tr class="separator:a7f0f8bcc88c30609d766a4e723a53dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02366e13d56b1124db9bf8281b73ca9a"><td class="memItemLeft" align="right" valign="top"><a id="a02366e13d56b1124db9bf8281b73ca9a" name="a02366e13d56b1124db9bf8281b73ca9a"></a>
<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nmax</b></td></tr>
<tr class="memdesc:a02366e13d56b1124db9bf8281b73ca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of nodes <br /></td></tr>
<tr class="separator:a02366e13d56b1124db9bf8281b73ca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d50257929003fb000e6bcc1db02fd6"><td class="memItemLeft" align="right" valign="top"><a id="a61d50257929003fb000e6bcc1db02fd6" name="a61d50257929003fb000e6bcc1db02fd6"></a>
<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m</b></td></tr>
<tr class="memdesc:a61d50257929003fb000e6bcc1db02fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of arcs <br /></td></tr>
<tr class="separator:a61d50257929003fb000e6bcc1db02fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e7022437bc38dc11cffe32d4b2332c"><td class="memItemLeft" align="right" valign="top"><a id="a93e7022437bc38dc11cffe32d4b2332c" name="a93e7022437bc38dc11cffe32d4b2332c"></a>
<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mmax</b></td></tr>
<tr class="memdesc:a93e7022437bc38dc11cffe32d4b2332c"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of arcs <br /></td></tr>
<tr class="separator:a93e7022437bc38dc11cffe32d4b2332c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e27f49150e9a14580fb313cc2777e00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6e27f49150e9a14580fb313cc2777e00">status</a></td></tr>
<tr class="memdesc:a6e27f49150e9a14580fb313cc2777e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">return status, see the comments to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8" title="returns the solution status">MCFGetStatus()</a> above.  <br /></td></tr>
<tr class="separator:a6e27f49150e9a14580fb313cc2777e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b691e0b125c33ab526888ab754e461"><td class="memItemLeft" align="right" valign="top"><a id="a89b691e0b125c33ab526888ab754e461" name="a89b691e0b125c33ab526888ab754e461"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Senstv</b></td></tr>
<tr class="memdesc:a89b691e0b125c33ab526888ab754e461"><td class="mdescLeft">&#160;</td><td class="mdescRight">true &lt;=&gt; the latest optimal solution should be exploited <br /></td></tr>
<tr class="separator:a89b691e0b125c33ab526888ab754e461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7624a057d988dd8f61b038ff459cd0b"><td class="memItemLeft" align="right" valign="top"><a id="ab7624a057d988dd8f61b038ff459cd0b" name="ab7624a057d988dd8f61b038ff459cd0b"></a>
<a class="el" href="classOPTtypes__di__unipi__it_1_1OPTtimers.html">OPTtimers</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>MCFt</b></td></tr>
<tr class="memdesc:ab7624a057d988dd8f61b038ff459cd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">timer for performances evaluation <br /></td></tr>
<tr class="separator:ab7624a057d988dd8f61b038ff459cd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b1c456efbc2e544b82cb6553f6df8d"><td class="memItemLeft" align="right" valign="top"><a id="a65b1c456efbc2e544b82cb6553f6df8d" name="a65b1c456efbc2e544b82cb6553f6df8d"></a>
<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EpsFlw</b></td></tr>
<tr class="memdesc:a65b1c456efbc2e544b82cb6553f6df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision for comparing arc flows / capacities <br /></td></tr>
<tr class="separator:a65b1c456efbc2e544b82cb6553f6df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9159ee7ca50477fd57f6854ff73b2874"><td class="memItemLeft" align="right" valign="top"><a id="a9159ee7ca50477fd57f6854ff73b2874" name="a9159ee7ca50477fd57f6854ff73b2874"></a>
<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EpsDfct</b></td></tr>
<tr class="memdesc:a9159ee7ca50477fd57f6854ff73b2874"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision for comparing node deficits <br /></td></tr>
<tr class="separator:a9159ee7ca50477fd57f6854ff73b2874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8c11b8ba9065dd3bc0f7b5ec423869"><td class="memItemLeft" align="right" valign="top"><a id="aad8c11b8ba9065dd3bc0f7b5ec423869" name="aad8c11b8ba9065dd3bc0f7b5ec423869"></a>
<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EpsCst</b></td></tr>
<tr class="memdesc:aad8c11b8ba9065dd3bc0f7b5ec423869"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision for comparing arc costs <br /></td></tr>
<tr class="separator:aad8c11b8ba9065dd3bc0f7b5ec423869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bad127f3e412819d99baff0c51e5be8"><td class="memItemLeft" align="right" valign="top"><a id="a8bad127f3e412819d99baff0c51e5be8" name="a8bad127f3e412819d99baff0c51e5be8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>MaxTime</b></td></tr>
<tr class="memdesc:a8bad127f3e412819d99baff0c51e5be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">max time (in seconds) in which MCF Solver can find an optimal solution (0 = no limits) <br /></td></tr>
<tr class="separator:a8bad127f3e412819d99baff0c51e5be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259eaddd4d91ec0a7d00ff6db0a3f40a"><td class="memItemLeft" align="right" valign="top"><a id="a259eaddd4d91ec0a7d00ff6db0a3f40a" name="a259eaddd4d91ec0a7d00ff6db0a3f40a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxIter</b></td></tr>
<tr class="memdesc:a259eaddd4d91ec0a7d00ff6db0a3f40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">max number of iterations in which MCF Solver can find an optimal solution (0 = no limits) <br /></td></tr>
<tr class="separator:a259eaddd4d91ec0a7d00ff6db0a3f40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This abstract base class defines a standard interface for (linear or convex quadartic separable) Min Cost Flow (MCF) problem solvers. </p>
<p>The data of the problem consist of a (directed) graph G = ( N , A ) with n = |N| nodes and m = |A| (directed) arcs. Each node &lsquo;i&rsquo; has a deficit b[ i ], i.e., the amount of flow that is produced/consumed by the node: source nodes (which produce flow) have negative deficits and sink nodes (which consume flow) have positive deficits. Each arc &lsquo;(i, j)&rsquo; has an upper capacity U[ i , j ], a linear cost coefficient C[ i , j ] and a (non negative) quadratic cost coefficient Q[ i , j ]. Flow variables X[ i , j ] represents the amount of flow to be sent on arc (i, j). Parallel arcs, i.e., multiple copies of the same arc &lsquo;(i, j)&rsquo; (with possibily different costs and/or capacities) are in general allowed. The formulation of the problem is therefore:  </p><p class="formulaDsp">
\[
 \min \sum_{ (i, j) \in A } C[ i , j ] X[ i, j ] +
                            Q[ i , j ] X[ i, j ]^2 / 2
\]
</p>
  <p class="formulaDsp">
\[
  \sum_{ (j, i) \in A } X[ j , i ] -
  \sum_{ (i, j) \in A } X[ i , j ] = b[ i ]
  \hspace{1cm} i \in N
  \hspace{1cm} (1)
\]
</p>
  <p class="formulaDsp">
\[
  0 \leq X[ i , j ] \leq U[ i , j ]
  \hspace{1cm} (i, j) \in A
  \hspace{1cm} (2)
\]
</p>
<p> The n equations (1) are the flow conservation constraints and the 2m inequalities (2) are the flow nonnegativity and capacity constraints. At least one of the flow conservation constraints is redundant, as the demands must be balanced ( \(\sum_{ i \in N } b[ i ] = 0\)); indeed, exactly n - ConnectedComponents( G ) flow conservation constraints are redundant, as demands must be balanced in each connected component of G. Let us denote by QA and LA the disjoint subsets of A containing, respectively, "quadratic" arcs (with Q[ i , j ] &gt; 0) and "linear" arcs (with Q[ i , j ] = 0); the (MCF) problem is linear if QA is empty, and nonlinear (convex quadratic) if QA is nonempty.</p>
<p>The dual of the problem is:  </p><p class="formulaDsp">
\[
 \max \sum_{ i \in N } Pi[ i ] b[ i ] -
      \sum_{ (i, j) \in A } W[ i , j ] U[ i , j ] -
      \sum_{ (i, j) \in AQ } V[ i , j ]^2 / ( 2 * Q[ i , j ] )
\]
</p>
  <p class="formulaDsp">
\[
  C[ i , j ] - Pi[ j ] + Pi[ i ] + W[ i , j ] - Z[ i , j ] = 0
  \hspace{1cm} (i, j) \in AL
  \hspace{1cm} (3.a)
\]
</p>
  <p class="formulaDsp">
\[
 C[ i , j ] - Pi[ j ] + Pi[ i ] + W[ i , j ] - Z[ i , j ] = V[ i , j ]
 \hspace{1cm} (i, j) \in AQ
 \hspace{1cm} (3.b)
\]
</p>
  <p class="formulaDsp">
\[
 W[ i , j ] \geq 0 \hspace{1cm} (i, j) \in A  \hspace{1cm} (4.a) 
\]
</p>
  <p class="formulaDsp">
\[
 Z[ i , j ] \geq 0 \hspace{1cm} (i, j) \in A  \hspace{1cm} (4.b) 
\]
</p>
<p> Pi[] is said the vector of node potentials for the problem, W[] are bound variables and Z[] are slack variables. Given Pi[], the quantities  </p><p class="formulaDsp">
\[
 RC[ i , j ] =  C[ i , j ] + Q[ i , j ] * X[ i , j ] - Pi[ j ] + Pi[ i ]
\]
</p>
<p> are said the "reduced costs" of arcs.</p>
<p>A primal and dual feasible solution pair is optimal if and only if the complementary slackness conditions  </p><p class="formulaDsp">
\[
 RC[ i , j ] &gt; 0 \Rightarrow X[ i , j ] = 0
\]
</p>
  <p class="formulaDsp">
\[
 RC[ i , j ] &lt; 0 \Rightarrow X[ i , j ] = U[ i , j ]
\]
</p>
<p> are satisfied for all arcs (i, j) of A.</p>
<p>The <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> class provides an interface with methods for managing and solving problems of this kind. Actually, the class can also be used as an interface for more general NonLinear MCF problems, where the cost function either nonseparable ( C( X ) ) or arc-separable ( \(\sum_{ (i, j) \in A } C_{i,j}( X[ i, j ] )\) ). However, solvers for NonLinear MCF problems are typically objective-function-specific, and there is no standard way for inputting a nonlinear function different from a separable convex quadratic one, so only the simplest form is dealt with in the interface, leaving more complex NonLinear parts to the interface of derived classes. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af6e60cb841150361862d6b895c523e0a" name="af6e60cb841150361862d6b895c523e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e60cb841150361862d6b895c523e0a">&#9670;&#160;</a></span>MCFParam</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0a">MCFParam</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible parameters of the MCF solver, to be used with the methods <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a3b295ebd5b5519017af591da788885ae" title="set integer parameters of the algorithm">SetPar()</a> and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ac66ea95b63fe61ce67e0f8544f200887" title="returns one of the integer parameters of the algorithm">GetPar()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aab35d3e473676b56fa123d6df3d855aa0" name="af6e60cb841150361862d6b895c523e0aab35d3e473676b56fa123d6df3d855aa0"></a>kMaxTime&#160;</td><td class="fielddoc"><p>max time </p>
</td></tr>
<tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aa50d3edcd55bc1dd84d4e1719430f9d20" name="af6e60cb841150361862d6b895c523e0aa50d3edcd55bc1dd84d4e1719430f9d20"></a>kMaxIter&#160;</td><td class="fielddoc"><p>max number of iteration </p>
</td></tr>
<tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aa753a94f6a06a5579eb0855479dfbb6b1" name="af6e60cb841150361862d6b895c523e0aa753a94f6a06a5579eb0855479dfbb6b1"></a>kEpsFlw&#160;</td><td class="fielddoc"><p>tolerance for flows </p>
</td></tr>
<tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aa409d9ed5655d184667a5e486e5110c6e" name="af6e60cb841150361862d6b895c523e0aa409d9ed5655d184667a5e486e5110c6e"></a>kEpsDfct&#160;</td><td class="fielddoc"><p>tolerance for deficits </p>
</td></tr>
<tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aaf263085cb23be60527c92896891cd12c" name="af6e60cb841150361862d6b895c523e0aaf263085cb23be60527c92896891cd12c"></a>kEpsCst&#160;</td><td class="fielddoc"><p>tolerance for costs </p>
</td></tr>
<tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aa7efdbe01bec821f08a391f9542086475" name="af6e60cb841150361862d6b895c523e0aa7efdbe01bec821f08a391f9542086475"></a>kReopt&#160;</td><td class="fielddoc"><p>whether or not to reoptimize </p>
</td></tr>
<tr><td class="fieldname"><a id="af6e60cb841150361862d6b895c523e0aa99ac8339170db67bf9af4a60362ef7e1" name="af6e60cb841150361862d6b895c523e0aa99ac8339170db67bf9af4a60362ef7e1"></a>kLastParam&#160;</td><td class="fielddoc"><p>dummy parameter: this is used to allow derived classes to "extend" the set of parameters. </p>
</td></tr>
</table>

</div>
</div>
<a id="a15ef269c5dd98eea5274eb03a3feb5fb" name="a15ef269c5dd98eea5274eb03a3feb5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ef269c5dd98eea5274eb03a3feb5fb">&#9670;&#160;</a></span>MCFStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fb">MCFStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible status of the MCF solver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1" name="a15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1"></a>kUnSolved&#160;</td><td class="fielddoc"><p>no solution available </p>
</td></tr>
<tr><td class="fieldname"><a id="a15ef269c5dd98eea5274eb03a3feb5fba42e6b26684acf67af002df88a9cf997c" name="a15ef269c5dd98eea5274eb03a3feb5fba42e6b26684acf67af002df88a9cf997c"></a>kOK&#160;</td><td class="fielddoc"><p>optimal solution found </p>
</td></tr>
<tr><td class="fieldname"><a id="a15ef269c5dd98eea5274eb03a3feb5fba142714524ffdfe9cfebaa1033fd1a18f" name="a15ef269c5dd98eea5274eb03a3feb5fba142714524ffdfe9cfebaa1033fd1a18f"></a>kStopped&#160;</td><td class="fielddoc"><p>optimization stopped </p>
</td></tr>
<tr><td class="fieldname"><a id="a15ef269c5dd98eea5274eb03a3feb5fba7db95dc60f32bc33a35f748f639cc6d0" name="a15ef269c5dd98eea5274eb03a3feb5fba7db95dc60f32bc33a35f748f639cc6d0"></a>kUnfeasible&#160;</td><td class="fielddoc"><p>problem is unfeasible </p>
</td></tr>
<tr><td class="fieldname"><a id="a15ef269c5dd98eea5274eb03a3feb5fba4b9de95ee3087851acd98262e09f0be8" name="a15ef269c5dd98eea5274eb03a3feb5fba4b9de95ee3087851acd98262e09f0be8"></a>kUnbounded&#160;</td><td class="fielddoc"><p>problem is unbounded </p>
</td></tr>
<tr><td class="fieldname"><a id="a15ef269c5dd98eea5274eb03a3feb5fbaacb2c04376333850bff6fb1065c0c171" name="a15ef269c5dd98eea5274eb03a3feb5fbaacb2c04376333850bff6fb1065c0c171"></a>kError&#160;</td><td class="fielddoc"><p>error in the solver </p>
</td></tr>
</table>

</div>
</div>
<a id="ad7b7f4459be059eae1a7d83a8e190c28" name="ad7b7f4459be059eae1a7d83a8e190c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b7f4459be059eae1a7d83a8e190c28">&#9670;&#160;</a></span>MCFAnswer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28">MCFAnswer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible reoptimization status of the MCF solver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad7b7f4459be059eae1a7d83a8e190c28a503f4e9dca6c8c12ea38f9e8c1be0126" name="ad7b7f4459be059eae1a7d83a8e190c28a503f4e9dca6c8c12ea38f9e8c1be0126"></a>kNo&#160;</td><td class="fielddoc"><p>no </p>
</td></tr>
<tr><td class="fieldname"><a id="ad7b7f4459be059eae1a7d83a8e190c28ace5b3b5f2037b0d65d161b53b7c940fe" name="ad7b7f4459be059eae1a7d83a8e190c28ace5b3b5f2037b0d65d161b53b7c940fe"></a>kYes&#160;</td><td class="fielddoc"><p>yes </p>
</td></tr>
</table>

</div>
</div>
<a id="adb1b139bac65f5f35bdadc7549a819de" name="adb1b139bac65f5f35bdadc7549a819de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1b139bac65f5f35bdadc7549a819de">&#9670;&#160;</a></span>MCFFlFrmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#adb1b139bac65f5f35bdadc7549a819de">MCFFlFrmt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible file formats in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6afe6fc886cba0606b766cf14b3d4fca" title="write the current MCF problem to an ostream">WriteMCF()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adb1b139bac65f5f35bdadc7549a819dea6e65d07cdd719be7d99902bb47920a37" name="adb1b139bac65f5f35bdadc7549a819dea6e65d07cdd719be7d99902bb47920a37"></a>kDimacs&#160;</td><td class="fielddoc"><p>DIMACS file format for MCF. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb1b139bac65f5f35bdadc7549a819deac27a029d7010490d53e1df36b39597e6" name="adb1b139bac65f5f35bdadc7549a819deac27a029d7010490d53e1df36b39597e6"></a>kQDimacs&#160;</td><td class="fielddoc"><p>quadratic DIMACS file format for MCF </p>
</td></tr>
<tr><td class="fieldname"><a id="adb1b139bac65f5f35bdadc7549a819dea65125719fd6c68bc3904a45937fcfd85" name="adb1b139bac65f5f35bdadc7549a819dea65125719fd6c68bc3904a45937fcfd85"></a>kMPS&#160;</td><td class="fielddoc"><p>MPS file format for LP. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb1b139bac65f5f35bdadc7549a819dea7efb98d1b3dfca0f601d4df644b418a0" name="adb1b139bac65f5f35bdadc7549a819dea7efb98d1b3dfca0f601d4df644b418a0"></a>kFWMPS&#160;</td><td class="fielddoc"><p>"Fixed Width" MPS format </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a52812a5637b5bef5b6168f7bd062aa86" name="a52812a5637b5bef5b6168f7bd062aa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52812a5637b5bef5b6168f7bd062aa86">&#9670;&#160;</a></span>MCFClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html">MCFClass</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>nmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>mmx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the class. </p>
<p>nmx and mmx, if provided, are taken to be respectively the maximum number of nodes and arcs in the network. If nonzero values are passed, memory allocation can be anticipated in the constructor, which is sometimes desirable. The maximum values are stored in the protected fields nmax and mmax, and can be changed with <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9" title="inputs a new network from memory">LoadNet()</a> [see below]; however, changing them typically requires memory allocation/deallocation, which is sometimes undesirable outside the constructor.</p>
<p>After that an object has been constructed, no problem is loaded; this has to be done with <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9" title="inputs a new network from memory">LoadNet()</a> [see below]. Thus, it is an error to invoke any method which requires the presence of a problem (typicall all except those in the initializations part). The base class provides two protected fields n and m for the current number of nodes and arcs, respectively, that are set to 0 in the constructor precisely to indicate that no instance is currently loaded. </p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aad8c11b8ba9065dd3bc0f7b5ec423869">MCFClass::EpsCst</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9159ee7ca50477fd57f6854ff73b2874">MCFClass::EpsDfct</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a65b1c456efbc2e544b82cb6553f6df8d">MCFClass::EpsFlw</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1">MCFClass::kUnSolved</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a61d50257929003fb000e6bcc1db02fd6">MCFClass::m</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a259eaddd4d91ec0a7d00ff6db0a3f40a">MCFClass::MaxIter</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8bad127f3e412819d99baff0c51e5be8">MCFClass::MaxTime</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab7624a057d988dd8f61b038ff459cd0b">MCFClass::MCFt</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a93e7022437bc38dc11cffe32d4b2332c">MCFClass::mmax</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7f0f8bcc88c30609d766a4e723a53dac">MCFClass::n</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a02366e13d56b1124db9bf8281b73ca9a">MCFClass::nmax</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a89b691e0b125c33ab526888ab754e461">MCFClass::Senstv</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6e27f49150e9a14580fb313cc2777e00">MCFClass::status</a>.</p>

</div>
</div>
<a id="a93c0882740d38b9f8eb05994a01f76b7" name="a93c0882740d38b9f8eb05994a01f76b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c0882740d38b9f8eb05994a01f76b7">&#9670;&#160;</a></span>~MCFClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html">MCFClass</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor of the class </p>
<p>Destructor of the class. The implementation in the base class only deletes the MCFt field. It is virtual, as it should be. </p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab7624a057d988dd8f61b038ff459cd0b">MCFClass::MCFt</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa55a46d5b60df521c30da61e222f6da9" name="aa55a46d5b60df521c30da61e222f6da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55a46d5b60df521c30da61e222f6da9">&#9670;&#160;</a></span>LoadNet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LoadNet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>nmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>mmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>pn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>pm</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>pU</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>pC</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>pDfct</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>pSn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>pEn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inputs a new network from memory </p>
<p>Inputs a new network from memory</p>
<p>The parameters nmx and mmx are the new max number of nodes and arcs, possibly overriding those set in the constructor [see above], altough at the likely cost of memory allocation and deallocation. Passing nmx == mmx == 0 is intended as a signal to the solver to deallocate everything and wait for new orders; in this case, all the other parameters are ignored.</p>
<p>Otherwise, in principle all the other parameters have to be provided. Actually, some of them may not be needed for special classes of MCF problems (e.g., costs in a MaxFlow problem, or start/end nodes in a problem defined over a graph with fixed topology, such as a complete graph). Also, passing 0 is allowed to set default values.</p>
<p>The meaning of the parameters is the following:</p>
<ul>
<li>pn is the current number of nodes of the network (&lt;= nmax).</li>
<li>pm is the number of arcs of the network (&lt;= mmax).</li>
<li>pU is the m-vector of the arc upper capacities; capacities must be nonnegative, but can in principle be infinite (== F_INF); passing pU == 0 means that all capacities are infinite;</li>
<li>pC is the m-vector of the arc costs; costs must be finite (&lt; C_INF); passing pC == 0 means that all costs must be 0.</li>
<li>pDfct is the n-vector of the node deficits; source nodes have negative deficits and sink nodes have positive deficits; passing pDfct == 0 means that all deficits must be 0 (a circulation problem);</li>
<li>pSn is the m-vector of the arc starting nodes; pSn == 0 is in principle not allowed, unless the topology of the graph is fixed;</li>
<li>pEn is the m-vector of the arc ending nodes; same comments as for pSn.</li>
</ul>
<p>Note that node "names" in the arrays pSn and pEn must go from 1 to pn if the macro USANAME0 [see above] is set to 0, while they must go from 0 to pn - 1 if USANAME0 is set to 1. In both cases, however, the deficit of the first node is read from the first (0-th) position of pDfct, that is if USANAME0 == 0 then the deficit of the node with name &lsquo;i&rsquo; is read from pDfct[ i - 1 ].</p>
<p>The data passed to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9" title="inputs a new network from memory">LoadNet()</a> can be used to specify that the arc &lsquo;i&rsquo; must not "exist" in the problem. This is done by passing pC[ i ] == C_INF; solvers which don't read costs are forced to read them in order to check this, unless they provide alternative solver-specific ways to accomplish the same tasks. These arcs are "closed", as for the effect of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa71f643926bec5b0634f66d112704205" title="&quot;close&quot; one arc">CloseArc()</a> [see below]. "invalid" costs (== C_INF) are set to 0 in order to being subsequently capable of "opening" them back with <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8e6eb03b7e44dbc8b8b845ac3fa7632a" title="re-opens a closed arc">OpenArc()</a> [see below]. The way in which these non-existent arcs are phisically dealt with is solver-specific; in some solvers, for instance, this could be obtained by simply putting their capacity to zero. Details about these issues should be found in the interface of derived classes.</p>
<p>Note that the quadratic part of the objective function, if any, is not dealt with in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9" title="inputs a new network from memory">LoadNet()</a>; it can only be separately provided with <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1a55e6b1dda20d5835b0a162f80463ac" title="change the quadratic coefficients of the arc costs">ChgQCoef()</a> [see below]. By default, the problem is linear, i.e., all coefficients of the second-order terms in the objective function are assumed to be zero. </p>

<p>Implemented in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFSimplex.html#a45b18001b8e3cea172e4bb102270ca94">MCFSimplex</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1RelaxIV.html#a45b18001b8e3cea172e4bb102270ca94">RelaxIV</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1SPTree.html#a45b18001b8e3cea172e4bb102270ca94">SPTree</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a34d79a2f00cf8a2416b2b3e41552e843">MCFClass::LoadDMX()</a>.</p>

</div>
</div>
<a id="a34d79a2f00cf8a2416b2b3e41552e843" name="a34d79a2f00cf8a2416b2b3e41552e843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d79a2f00cf8a2416b2b3e41552e843">&#9670;&#160;</a></span>LoadDMX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoadDMX </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>DMXs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>IsQuad</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read a MCF instance from a stream </p>
<p>Read a MCF instance in DIMACS standard format from the istream. The format is the following. The first line must be</p>
<p>p min number_of_nodes number_of_arcs</p>
<p>Then the node definition lines must be found, in the form</p>
<p>n node_number node_supply</p>
<p>Not all nodes need have a node definition line; these are given zero supply, i.e., they are transhipment nodes (supplies are the opposite of deficits, i.e., a node with positive supply is a source node). Finally, the arc definition lines must be found, in the form</p>
<p>a start_node end_node lower_bound upper_bound flow_cost</p>
<p>There must be exactly number_of_arcs arc definition lines in the file.</p>
<p>This method is <em>not</em> pure virtual because an implementation is provided by the base class, using the <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9" title="inputs a new network from memory">LoadNet()</a> method (which <em>is</em> pure virtual). However, the method <em>is</em> virtual to allow derived classes to implement more efficient versions, should they have any reason to do so.</p>
<dl class="section note"><dt>Note</dt><dd>Actually, the file format accepted by LoadDMX (at least in the base class implementation) is more general than the DIMACS standard format, in that it is allowed to mix node and arc definitions in any order, while the DIMACS file requires all node information to appear before all arc information.</dd>
<dd>
Other than for the above, this method is assumed to allow for quadratic* Dimacs files, encoding for convex quadratic separable Min Cost Flow instances. This is a simple extension where each arc descriptor has a sixth field, &lt;quadratic cost&gt;. The provided istream is assumed to be quadratic Dimacs file if IsQuad is true, and a regular linear Dimacs file otherwise. </dd></dl>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1a55e6b1dda20d5835b0a162f80463ac">MCFClass::ChgQCoef()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9">MCFClass::LoadNet()</a>.</p>

</div>
</div>
<a id="a0554708d9abb0e079a8d6f073def9bab" name="a0554708d9abb0e079a8d6f073def9bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0554708d9abb0e079a8d6f073def9bab">&#9670;&#160;</a></span>PreProcess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PreProcess </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pre-process the instamce </p>
<p>Extract a smaller/easier equivalent MCF problem. The data of the instance is changed and the easier one is solved instead of the original one. In the MCF case, preprocessing may involve reducing bounds, identifying disconnected components of the graph etc. However, proprocessing is solver-specific.</p>
<p>This method can be implemented by derived classes in their solver-specific way. Preprocessing may reveal unboundedness or unfeasibility of the problem; if that happens, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a0554708d9abb0e079a8d6f073def9bab" title="pre-process the instamce">PreProcess()</a> should properly set the &lsquo;status&rsquo; field, that can then be read with <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8" title="returns the solution status">MCFGetStatus()</a> [see below].</p>
<p>Note that preprocessing may destroy all the solution information. Also, it may be allowed to change the data of the problem, such as costs/capacities of the arcs.</p>
<p>A valid preprocessing is doing nothing, and that's what the default implementation of this method (that is <em>not</em> pure virtual) does. </p>

<p>Reimplemented in <a class="el" href="classMCFClass__di__unipi__it_1_1RelaxIV.html#a734f7a51c509f1f28ec605453cf6ed0f">RelaxIV</a>.</p>

</div>
</div>
<a id="a3b295ebd5b5519017af591da788885ae" name="a3b295ebd5b5519017af591da788885ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b295ebd5b5519017af591da788885ae">&#9670;&#160;</a></span>SetPar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetPar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set integer parameters of the algorithm </p>
<p>Set integer parameters of the algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td>is the parameter to be set; the enum MCFParam can be used, but 'par' is an int (every enum is an int) so that the method can be extended by derived classes for the setting of their parameters</td></tr>
    <tr><td class="paramname">value</td><td>is the value to assign to the parameter. <br  />
</td></tr>
  </table>
  </dd>
</dl>
<p>The base class implementation handles these parameters:</p>
<ul>
<li>kMaxIter: the max number of iterations in which the MCF Solver can find an optimal solution (default 0, which means no limit)</li>
<li>kReopt: tells the solver if it has to reoptimize. The implementation in the base class sets a flag, the protected <code>bool</code> field <code>Senstv</code>; if true (default) this field instructs the MCF solver to try to exploit the information about the latest optimal solution to speedup the optimization of the current problem, while if the field is false the MCF solver should restart the optimization "from scratch" discarding any previous information. Usually reoptimization speeds up the computation considerably, but this is not always true, especially if the data of the problem changes a lot. </li>
</ul>

<p>Reimplemented in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a12105bbd99b8b7ad7efae3bb0c222b3c">MCFCplex</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFSimplex.html#aebda2a23b313bb3ab143e66137ada924">MCFSimplex</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1RelaxIV.html#a12105bbd99b8b7ad7efae3bb0c222b3c">RelaxIV</a>.</p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa50d3edcd55bc1dd84d4e1719430f9d20">MCFClass::kMaxIter</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa7efdbe01bec821f08a391f9542086475">MCFClass::kReopt</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28ace5b3b5f2037b0d65d161b53b7c940fe">MCFClass::kYes</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a259eaddd4d91ec0a7d00ff6db0a3f40a">MCFClass::MaxIter</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a89b691e0b125c33ab526888ab754e461">MCFClass::Senstv</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a64a55cf140fd8543ab0cf88cc052d8d7">MCFCplex::SetPar()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a12105bbd99b8b7ad7efae3bb0c222b3c">MCFCplex::SetPar()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1RelaxIV.html#a12105bbd99b8b7ad7efae3bb0c222b3c">RelaxIV::SetPar()</a>.</p>

</div>
</div>
<a id="a1d1efc4bd7bee3a0cf9366536feb463a" name="a1d1efc4bd7bee3a0cf9366536feb463a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1efc4bd7bee3a0cf9366536feb463a">&#9670;&#160;</a></span>SetPar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetPar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set float parameters of the algorithm. </p>
<p>Set float parameters of the algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td>is the parameter to be set; the enum MCFParam can be used, but 'par' is an int (every enum is an int) so that the method can be extended by derived classes for the setting of their parameters</td></tr>
    <tr><td class="paramname">value</td><td>is the value to assign to the parameter. <br  />
</td></tr>
  </table>
  </dd>
</dl>
<p>The base class implementation handles these parameters:</p>
<ul>
<li>kEpsFlw: sets the tolerance for controlling if the flow on an arc is zero. This also sets the tolerance for controlling if a node deficit is zero (see kEpsDfct) to val * max_number_of_nodes; this value should be safe for graphs in which any node has less than max_number_of_nodes adjacent nodes, i.e., for all graphs but for very dense ones with "parallel arcs"</li>
<li>kEpsDfct: sets the tolerance for controlling if a node deficit is zero, in case a better value than that autmatically set by kEpsFlw (see above) is available (e.g., val * k would be good if no node has more than k neighbours)</li>
<li>kEpsCst: sets the tolerance for controlling if the reduced cost of an arc is zero. A feasible solution satisfying eps-complementary slackness, i.e., such that  <p class="formulaDsp">
\[
             RC[ i , j ] &lt; - eps \Rightarrow X[ i , j ] = U[ ij ]
            \]
</p>
 and  <p class="formulaDsp">
\[
             RC[ i , j ] &gt; eps \Rightarrow X[ i , j ] == 0 ,
            \]
</p>
 is known to be ( eps * n )-optimal.</li>
<li>kMaxTime: sets the max time (in seconds) in which the MCF Solver can find an optimal solution (default 0, which means no limit). </li>
</ul>

<p>Reimplemented in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a64a55cf140fd8543ab0cf88cc052d8d7">MCFCplex</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFSimplex.html#ae6eb12cc8e2e124b236bf84ebeddab70">MCFSimplex</a>.</p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aad8c11b8ba9065dd3bc0f7b5ec423869">MCFClass::EpsCst</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9159ee7ca50477fd57f6854ff73b2874">MCFClass::EpsDfct</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a65b1c456efbc2e544b82cb6553f6df8d">MCFClass::EpsFlw</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aaf263085cb23be60527c92896891cd12c">MCFClass::kEpsCst</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa409d9ed5655d184667a5e486e5110c6e">MCFClass::kEpsDfct</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa753a94f6a06a5579eb0855479dfbb6b1">MCFClass::kEpsFlw</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aab35d3e473676b56fa123d6df3d855aa0">MCFClass::kMaxTime</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1">MCFClass::kUnSolved</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8bad127f3e412819d99baff0c51e5be8">MCFClass::MaxTime</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a02366e13d56b1124db9bf8281b73ca9a">MCFClass::nmax</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6e27f49150e9a14580fb313cc2777e00">MCFClass::status</a>.</p>

</div>
</div>
<a id="ac66ea95b63fe61ce67e0f8544f200887" name="ac66ea95b63fe61ce67e0f8544f200887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66ea95b63fe61ce67e0f8544f200887">&#9670;&#160;</a></span>GetPar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetPar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns one of the integer parameters of the algorithm </p>
<p>This method returns one of the integer parameters of the algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td>is the parameter to return [see SetPar( int ) for comments];</td></tr>
    <tr><td class="paramname">val</td><td>upon return, it will contain the value of the parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>The base class implementation handles the parameters kMaxIter and kReopt. </p>

<p>Reimplemented in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a1509aef1f7e7465e2a857f701239a8b3">MCFCplex</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1RelaxIV.html#a1509aef1f7e7465e2a857f701239a8b3">RelaxIV</a>.</p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa50d3edcd55bc1dd84d4e1719430f9d20">MCFClass::kMaxIter</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28a503f4e9dca6c8c12ea38f9e8c1be0126">MCFClass::kNo</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa7efdbe01bec821f08a391f9542086475">MCFClass::kReopt</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad7b7f4459be059eae1a7d83a8e190c28ace5b3b5f2037b0d65d161b53b7c940fe">MCFClass::kYes</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a259eaddd4d91ec0a7d00ff6db0a3f40a">MCFClass::MaxIter</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a89b691e0b125c33ab526888ab754e461">MCFClass::Senstv</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a21e5c44c67506282ee8b478bf7e55790">MCFCplex::GetPar()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1RelaxIV.html#a21e5c44c67506282ee8b478bf7e55790">RelaxIV::GetPar()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a1509aef1f7e7465e2a857f701239a8b3">MCFCplex::GetPar()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1RelaxIV.html#a1509aef1f7e7465e2a857f701239a8b3">RelaxIV::GetPar()</a>.</p>

</div>
</div>
<a id="a677caf4176eef1509a0fdf87c0662897" name="a677caf4176eef1509a0fdf87c0662897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677caf4176eef1509a0fdf87c0662897">&#9670;&#160;</a></span>GetPar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetPar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns one of the double parameters of the algorithm </p>
<p>This method returns one of the double parameters of the algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td>is the parameter to return [see SetPar( double ) for comments];</td></tr>
    <tr><td class="paramname">val</td><td>upon return, it will contain the value of the parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>The base class implementation handles the parameters kEpsFlw, kEpsDfct, kEpsCst, and kMaxTime. </p>

<p>Reimplemented in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a21e5c44c67506282ee8b478bf7e55790">MCFCplex</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1RelaxIV.html#a21e5c44c67506282ee8b478bf7e55790">RelaxIV</a>.</p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aad8c11b8ba9065dd3bc0f7b5ec423869">MCFClass::EpsCst</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9159ee7ca50477fd57f6854ff73b2874">MCFClass::EpsDfct</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a65b1c456efbc2e544b82cb6553f6df8d">MCFClass::EpsFlw</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aaf263085cb23be60527c92896891cd12c">MCFClass::kEpsCst</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa409d9ed5655d184667a5e486e5110c6e">MCFClass::kEpsDfct</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aa753a94f6a06a5579eb0855479dfbb6b1">MCFClass::kEpsFlw</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af6e60cb841150361862d6b895c523e0aab35d3e473676b56fa123d6df3d855aa0">MCFClass::kMaxTime</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8bad127f3e412819d99baff0c51e5be8">MCFClass::MaxTime</a>.</p>

</div>
</div>
<a id="a5441232979a0ac98410d765b04830eeb" name="a5441232979a0ac98410d765b04830eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5441232979a0ac98410d765b04830eeb">&#9670;&#160;</a></span>SetMCFTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetMCFTime </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TimeIt</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the timer of the code </p>
<p>Allocate an OPTtimers object [see OPTtypes.h] to be used for timing the methods of the class. The time can be read with <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a0c950787358582eb9038bd8f9dcfb070" title="Like TimeMCF( double , double ) [see above], but returns the total time.">TimeMCF()</a> [see below]. By default, or if SetMCFTime( false ) is called, no timing is done. Note that, since all the relevant methods ot the class are pure virtual, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> can only manage the OPTtimers object, but it is due to derived classes to actually implement the timing.</p>
<dl class="section note"><dt>Note</dt><dd>time accumulates over the calls: calling <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a5441232979a0ac98410d765b04830eeb" title="set the timer of the code">SetMCFTime()</a>, however, resets the counters, allowing to time specific groups of calls.</dd>
<dd>
of course, setting kMaxTime [see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a3b295ebd5b5519017af591da788885ae" title="set integer parameters of the algorithm">SetPar()</a> above] to any nonzero value has no effect unless SetMCFTime( true ) has been called. </dd></dl>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab7624a057d988dd8f61b038ff459cd0b">MCFClass::MCFt</a>, and <a class="el" href="classOPTtypes__di__unipi__it_1_1OPTtimers.html#a83cd017adcfdb6d5b0a66aea8f6508b6">OPTtimers::ReSet()</a>.</p>

</div>
</div>
<a id="ac0d96429d896a2d878a5f057535ab1ee" name="ac0d96429d896a2d878a5f057535ab1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d96429d896a2d878a5f057535ab1ee">&#9670;&#160;</a></span>SolveMCF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SolveMCF </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>solve the problem </p>
<p>Solver of the Min Cost Flow Problem. Attempts to solve the MCF instance currently loaded in the object. </p>

</div>
</div>
<a id="a03701bebeaaf83d06f9d42a84ab92fd8" name="a03701bebeaaf83d06f9d42a84ab92fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03701bebeaaf83d06f9d42a84ab92fd8">&#9670;&#160;</a></span>MCFGetStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MCFGetStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the solution status </p>
<p>Returns an int describing the current status of the MCF solver. Possible return values are:</p>
<ul>
<li>kUnSolved <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ac0d96429d896a2d878a5f057535ab1ee" title="solve the problem">SolveMCF()</a> has not been called yet, or the data of the problem has been changed since the last call;</li>
<li>kOK optimization has been carried out succesfully;</li>
<li>kStopped optimization have been stopped before that the stopping conditions of the solver applied, e.g. because of the maximum allowed number of "iterations" [see SetPar( int )] or the maximum allowed time [see SetPar( double )] has been reached; this is not necessarily an error, as it might just be required to re-call <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ac0d96429d896a2d878a5f057535ab1ee" title="solve the problem">SolveMCF()</a> giving it more "resources" in order to solve the problem;</li>
<li>kUnfeasible if the current MCF instance is (primal) unfeasible;</li>
<li>kUnbounded if the current MCF instance is (primal) unbounded (this can only happen if the solver actually allows F_INF capacities, which is nonstandard in the interface);</li>
<li>kError if there was an error during the optimization; this typically indicates that computation cannot be resumed, although solver-dependent ways of dealing with solver-dependent errors may exist.</li>
</ul>
<p><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> has a protected <code>int</code> <code>member</code> <code>status</code> <code>that</code> can be used by derived classes to hold status information and that is returned by the standard implementation of this method. Note that <code>status</code> <code>is</code> an <code>int</code> <code>and</code> not an <code>enum</code> <code></code>, and that an <code>int</code> <code>is</code> returned by this method, in order to allow the derived classes to extend the set of return values if they need to do so. </p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6e27f49150e9a14580fb313cc2777e00">MCFClass::status</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af1bfb9cbd09a1f0851627169103e92a2">MCFClass::MCFGetDFO()</a>.</p>

</div>
</div>
<a id="abbddb4d3d6e3ec68f849d64618de037d" name="abbddb4d3d6e3ec68f849d64618de037d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbddb4d3d6e3ec68f849d64618de037d">&#9670;&#160;</a></span>MCFGetX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFGetX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the optimal flow solution in a vector </p>
<p>Write the optimal flow solution in the vector F[]. If nms == 0, F[] will be in "dense" format, i.e., the flow relative to arc &lsquo;i&rsquo; (i in 0 .. m - 1) is written in F[ i ]. If nms != 0, F[] will be in "sparse" format, i.e., the indices of the nonzero elements in the flow solution are written in nms (that is then Inf&lt; Index &gt;()-terminated) and the flow value of arc nms[ i ] is written in F[ i ]. Note that nms is not* guaranteed to be ordered. Also, note that, unlike <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aef9fe72baa305e432331d4f7e98f6b2c" title="return a read-only pointer to an the reduced costs">MCFGetRC()</a> and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9589c18168466325844bc8d43ab60518" title="return a read-only pointer to the node potentials">MCFGetPi()</a> [see below], nms is an <em>output</em> of the method.</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). </p>

<p>Implemented in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a6bc4ca3117e650f80114f077b40bbdd0">MCFCplex</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFSimplex.html#a6bc4ca3117e650f80114f077b40bbdd0">MCFSimplex</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1SPTree.html#a6bc4ca3117e650f80114f077b40bbdd0">SPTree</a>.</p>

</div>
</div>
<a id="a76b0e00ff4baafb00ff03e213ca83dbd" name="a76b0e00ff4baafb00ff03e213ca83dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b0e00ff4baafb00ff03e213ca83dbd">&#9670;&#160;</a></span>MCFGetX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> MCFGetX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a read-only pointer to the flow solution </p>
<p>Return a read-only pointer to an internal data structure containing the flow solution in "dense" format. Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a76b0e00ff4baafb00ff03e213ca83dbd">MCFCplex</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFSimplex.html#a76b0e00ff4baafb00ff03e213ca83dbd">MCFSimplex</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1SPTree.html#a76b0e00ff4baafb00ff03e213ca83dbd">SPTree</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87f68e5fc8390d9fa6e4c1ff6552df0c">MCFClass::CheckDSol()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7c8357e94656cea56777203f7d4345b2">MCFClass::CheckPSol()</a>.</p>

</div>
</div>
<a id="a7a4966a98c7ffa909057064beb4507a5" name="a7a4966a98c7ffa909057064beb4507a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4966a98c7ffa909057064beb4507a5">&#9670;&#160;</a></span>HaveNewX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HaveNewX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tells if a different flow solution is available </p>
<p>Return true if a different (approximately) optimal primal solution is available. If the method returns true, then any subsequent call to (any form of) <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a76b0e00ff4baafb00ff03e213ca83dbd" title="return a read-only pointer to the flow solution">MCFGetX()</a> will return a different primal solution w.r.t. the one that was being returned <em>before</em> the call to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7a4966a98c7ffa909057064beb4507a5" title="tells if a different flow solution is available">HaveNewX()</a>. This solution need not be optimal (although, ideally, it has to be "good); this can be checked by comparing its objective function value, that will be returned by a call to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8fa24610af25b480e674fd71aa941ecd" title="return the objective function value of the primal solution">MCFGetFO()</a>.</p>
<p>Any subsequent call of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7a4966a98c7ffa909057064beb4507a5" title="tells if a different flow solution is available">HaveNewX()</a> that returns true produces a new solution, until the first that returns false; from then on, no new solutions will be generated until something changes in the problem's data.</p>
<p>Note that a default implementation of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7a4966a98c7ffa909057064beb4507a5" title="tells if a different flow solution is available">HaveNewX()</a> is provided which is good for those solvers that only produce one optimal primal solution. </p>

</div>
</div>
<a id="a699c8adb373a2d8804c6d56c8b29b3f1" name="a699c8adb373a2d8804c6d56c8b29b3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699c8adb373a2d8804c6d56c8b29b3f1">&#9670;&#160;</a></span>MCFGetPi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFGetPi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>writes the optimal node potentials in a vector </p>
<p>Writes the optimal node potentials in the vector P[]. If nms == 0, the node potential of node &lsquo;i&rsquo; (i in 0 .. n - 1) is written in P[ i ] (note that here node names always start from zero, regardless to the value of USENAME0). If nms != 0, it must point to a vector of indices in 0 .. n - 1 (ordered in increasing sense and Inf&lt; Index &gt;()-terminated), and the node potential of nms[ i ] is written in P[ i ]. Note that, unlike <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a76b0e00ff4baafb00ff03e213ca83dbd" title="return a read-only pointer to the flow solution">MCFGetX()</a> above, nms is an <em>input</em> of the method.</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the nodes &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFn() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to nodes which are <em>both</em> in nms[] and whose index is in the correct range are returned. </p>

<p>Implemented in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#aa1059f566333ac3a025751d6b1bdcbda">MCFCplex</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFSimplex.html#aa1059f566333ac3a025751d6b1bdcbda">MCFSimplex</a>.</p>

</div>
</div>
<a id="a9589c18168466325844bc8d43ab60518" name="a9589c18168466325844bc8d43ab60518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9589c18168466325844bc8d43ab60518">&#9670;&#160;</a></span>MCFGetPi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> MCFGetPi </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a read-only pointer to the node potentials </p>
<p>Return a read-only pointer to an internal data structure containing the node potentials. Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a9589c18168466325844bc8d43ab60518">MCFCplex</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFSimplex.html#a9589c18168466325844bc8d43ab60518">MCFSimplex</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1SPTree.html#a57d610614e8bb3939b61abade12cf9f9">SPTree</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87f68e5fc8390d9fa6e4c1ff6552df0c">MCFClass::CheckDSol()</a>.</p>

</div>
</div>
<a id="a87b2b6516a7874ac55145312bd2d55bb" name="a87b2b6516a7874ac55145312bd2d55bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b2b6516a7874ac55145312bd2d55bb">&#9670;&#160;</a></span>HaveNewPi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HaveNewPi </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tells if a different dual solution is available </p>
<p>Return true if a different (approximately) optimal dual solution is available. If the method returns true, then any subsequent call to (any form of) <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9589c18168466325844bc8d43ab60518" title="return a read-only pointer to the node potentials">MCFGetPi()</a> will return a different dual solution, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aef9fe72baa305e432331d4f7e98f6b2c" title="return a read-only pointer to an the reduced costs">MCFGetRC()</a> [see below] will return the corresponding reduced costs. The new solution need not be optimal (although, ideally, it has to be "good); this can be checked by comparing its objective function value, that will be returned by a call to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af1bfb9cbd09a1f0851627169103e92a2" title="return the objective function value of the dual solution">MCFGetDFO()</a> [see below].</p>
<p>Any subsequent call of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87b2b6516a7874ac55145312bd2d55bb" title="tells if a different dual solution is available">HaveNewPi()</a> that returns true produces a new solution, until the first that returns false; from then on, no new solutions will be generated until something changes in the problem's data.</p>
<p>Note that a default implementation of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87b2b6516a7874ac55145312bd2d55bb" title="tells if a different dual solution is available">HaveNewPi()</a> is provided which is good for those solvers that only produce one optimal dual solution. </p>

</div>
</div>
<a id="a5426e6d07ed8bf6328aad9c256e5c602" name="a5426e6d07ed8bf6328aad9c256e5c602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5426e6d07ed8bf6328aad9c256e5c602">&#9670;&#160;</a></span>MCFGetRC() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFGetRC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>CR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the reduced costs in a vector </p>
<p>Write the reduced costs corresponding to the current dual solution in RC[]. If nms == 0, the reduced cost of arc &lsquo;i&rsquo; (i in 0 .. m - 1) is written in RC[ i ]; if nms != 0, it must point to a vector of indices in 0 .. m - 1 (ordered in increasing sense and Inf&lt; Index &gt;()-terminated), and the reduced cost of arc nms[ i ] is written in RC[ i ]. Note that, unlike <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a76b0e00ff4baafb00ff03e213ca83dbd" title="return a read-only pointer to the flow solution">MCFGetX()</a> above, nms is an <em>input</em> of the method.</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms[] and whose index is in the correct range are returned.</p>
<dl class="section note"><dt>Note</dt><dd>the output of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aef9fe72baa305e432331d4f7e98f6b2c" title="return a read-only pointer to an the reduced costs">MCFGetRC()</a> will change after any call to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87b2b6516a7874ac55145312bd2d55bb" title="tells if a different dual solution is available">HaveNewPi()</a> [see above] which returns true. </dd></dl>

<p>Implemented in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a96089bb51433c37e3a61aea51ec799e8">MCFCplex</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFSimplex.html#a96089bb51433c37e3a61aea51ec799e8">MCFSimplex</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1SPTree.html#a96089bb51433c37e3a61aea51ec799e8">SPTree</a>.</p>

</div>
</div>
<a id="aef9fe72baa305e432331d4f7e98f6b2c" name="aef9fe72baa305e432331d4f7e98f6b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9fe72baa305e432331d4f7e98f6b2c">&#9670;&#160;</a></span>MCFGetRC() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> MCFGetRC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a read-only pointer to an the reduced costs </p>
<p>Return a read-only pointer to an internal data structure containing the reduced costs. Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method.</p>
<dl class="section note"><dt>Note</dt><dd>the output of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aef9fe72baa305e432331d4f7e98f6b2c" title="return a read-only pointer to an the reduced costs">MCFGetRC()</a> will change after any call to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87b2b6516a7874ac55145312bd2d55bb" title="tells if a different dual solution is available">HaveNewPi()</a> which returns true. </dd></dl>

<p>Reimplemented in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#aef9fe72baa305e432331d4f7e98f6b2c">MCFCplex</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFSimplex.html#aef9fe72baa305e432331d4f7e98f6b2c">MCFSimplex</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1SPTree.html#aef9fe72baa305e432331d4f7e98f6b2c">SPTree</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87f68e5fc8390d9fa6e4c1ff6552df0c">MCFClass::CheckDSol()</a>.</p>

</div>
</div>
<a id="aa34bf85e8dd62d8940581130f5a2b9ed" name="aa34bf85e8dd62d8940581130f5a2b9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34bf85e8dd62d8940581130f5a2b9ed">&#9670;&#160;</a></span>MCFGetRC() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> MCFGetRC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the reduced cost of the i-th arc </p>
<p>Return the reduced cost of the i-th arc. This information should be cheapily available in most implementations.</p>
<dl class="section note"><dt>Note</dt><dd>the output of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aef9fe72baa305e432331d4f7e98f6b2c" title="return a read-only pointer to an the reduced costs">MCFGetRC()</a> will change after any call to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87b2b6516a7874ac55145312bd2d55bb" title="tells if a different dual solution is available">HaveNewPi()</a> which returns true. </dd></dl>

<p>Implemented in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFCplex.html#a81ab0d98d3a6889baf9433964ccd5171">MCFCplex</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFSimplex.html#a81ab0d98d3a6889baf9433964ccd5171">MCFSimplex</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1SPTree.html#a81ab0d98d3a6889baf9433964ccd5171">SPTree</a>.</p>

</div>
</div>
<a id="a8fa24610af25b480e674fd71aa941ecd" name="a8fa24610af25b480e674fd71aa941ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa24610af25b480e674fd71aa941ecd">&#9670;&#160;</a></span>MCFGetFO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a> MCFGetFO </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the objective function value of the primal solution </p>
<p>Return the objective function value of the primal solution currently returned by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a76b0e00ff4baafb00ff03e213ca83dbd" title="return a read-only pointer to the flow solution">MCFGetX()</a>.</p>
<p>If <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8" title="returns the solution status">MCFGetStatus()</a> == kOK, this is guaranteed to be the optimal objective function value of the problem (to within the optimality tolerances), but only prior to any call to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7a4966a98c7ffa909057064beb4507a5" title="tells if a different flow solution is available">HaveNewX()</a> that returns true. <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8fa24610af25b480e674fd71aa941ecd" title="return the objective function value of the primal solution">MCFGetFO()</a> typically returns Inf&lt; FONumber &gt;() if <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8" title="returns the solution status">MCFGetStatus()</a> == kUnfeasible and</p><ul>
<li>Inf&lt; FONumber &gt;() if <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8" title="returns the solution status">MCFGetStatus()</a> == kUnbounded. If <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8" title="returns the solution status">MCFGetStatus()</a> == kStopped and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8fa24610af25b480e674fd71aa941ecd" title="return the objective function value of the primal solution">MCFGetFO()</a> returns a finite value, it must be an upper bound on the optimal objective function value (typically, the objective function value of one primal feasible solution). </li>
</ul>

<p>Implemented in <a class="el" href="classMCFClass__di__unipi__it_1_1SPTree.html#aec484af2201a1e015f08f20500d09a62">SPTree</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87f68e5fc8390d9fa6e4c1ff6552df0c">MCFClass::CheckDSol()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7c8357e94656cea56777203f7d4345b2">MCFClass::CheckPSol()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af1bfb9cbd09a1f0851627169103e92a2">MCFClass::MCFGetDFO()</a>.</p>

</div>
</div>
<a id="af1bfb9cbd09a1f0851627169103e92a2" name="af1bfb9cbd09a1f0851627169103e92a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bfb9cbd09a1f0851627169103e92a2">&#9670;&#160;</a></span>MCFGetDFO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a> MCFGetDFO </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the objective function value of the dual solution </p>
<p>Return the objective function value of the dual solution currently returned by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9589c18168466325844bc8d43ab60518" title="return a read-only pointer to the node potentials">MCFGetPi()</a> / <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aef9fe72baa305e432331d4f7e98f6b2c" title="return a read-only pointer to an the reduced costs">MCFGetRC()</a>. This value (possibly) changes after any call to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87b2b6516a7874ac55145312bd2d55bb" title="tells if a different dual solution is available">HaveNewPi()</a> that returns true. The relations between <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8" title="returns the solution status">MCFGetStatus()</a> and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af1bfb9cbd09a1f0851627169103e92a2" title="return the objective function value of the dual solution">MCFGetDFO()</a> are analogous to these of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8fa24610af25b480e674fd71aa941ecd" title="return the objective function value of the primal solution">MCFGetFO()</a>, except that a finite value corresponding to kStopped must be a lower bound on the optimal objective function value (typically, the objective function value one dual feasible solution).</p>
<p>A default implementation is provided for <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#af1bfb9cbd09a1f0851627169103e92a2" title="return the objective function value of the dual solution">MCFGetDFO()</a>, which is good for MCF solvers where the primal and dual optimal solution values always are identical (except if the problem is unfeasible/unbounded). </p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fbaacb2c04376333850bff6fb1065c0c171">MCFClass::kError</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fba142714524ffdfe9cfebaa1033fd1a18f">MCFClass::kStopped</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1">MCFClass::kUnSolved</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8fa24610af25b480e674fd71aa941ecd">MCFClass::MCFGetFO()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8">MCFClass::MCFGetStatus()</a>.</p>

</div>
</div>
<a id="a7eb96eea797b718349097ed6dc6aaab1" name="a7eb96eea797b718349097ed6dc6aaab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb96eea797b718349097ed6dc6aaab1">&#9670;&#160;</a></span>MCFGetUnfCut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> MCFGetUnfCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>Cut</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return an unfeasibility certificate </p>
<p>Return an unfeasibility certificate. In an unfeasible MCF problem, unfeasibility can always be reduced to the existence of a cut (subset of nodes of the graph) such as either:</p>
<ul>
<li>the inverse of the deficit of the cut (the sum of all the deficits of the nodes in the cut) is larger than the forward capacity of the cut (sum of the capacities of forward arcs in the cut); that is, the nodes in the cut globally produce more flow than can be routed to sinks outside the cut;</li>
<li>the deficit of the cut is larger than the backward capacity of the cut (sum of the capacities of backward arcs in the cut); that is, the nodes in the cut globally require more flow than can be routed to them from sources outside the cut.</li>
</ul>
<p>When detecting unfeasibility, MCF solvers are typically capable to provide one such cut. This information can be useful - typically, the only way to make the problem feasible is to increase the capacity of at least one of the forward/backward arcs of the cut -, and this method is provided for getting it. It can be called only if <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8" title="returns the solution status">MCFGetStatus()</a> == kUnfeasible, and should write in Cut the set of names of nodes in the unfeasible cut (note that node names depend on USENAME0), Inf&lt; Index &gt;()-terminated, returning the deficit of the cut (which allows to distinguish which of the two cases above hold). In general, no special properties can be expected from the returned cut, but solvers should be able to provide e.g. "small" cuts.</p>
<p>However, not all solvers may be (easily) capable of providing this information; thus, returning 0 (no cut) is allowed, as in the base class implementation, to signify that this information is not available. </p>

</div>
</div>
<a id="aafe7f2953cd36ea8efe5790d071ca65c" name="aafe7f2953cd36ea8efe5790d071ca65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe7f2953cd36ea8efe5790d071ca65c">&#9670;&#160;</a></span>MCFGetUnbCycl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFGetUnbCycl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>ArcPred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return an unboundedness certificate </p>
<p>Return an unboundedness certificate. In an unbounded MCF problem, unboundedness can always be reduced to the existence of a directed cycle with negative cost and all arcs having infinite capacity. When detecting unboundedness, MCF solvers are typically capable to provide one such cycle. This information can be useful, and this method is provided for getting it. It can be called only if <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8" title="returns the solution status">MCFGetStatus()</a> == kUnbounded, and writes in Pred[] and ArcPred[], respectively, the node and arc predecessor function of the cycle. That is, if node &lsquo;i&rsquo; belongs to the cycle then &lsquo;Pred[ i ]&rsquo; contains the name of the predecessor of &lsquo;j&rsquo; of &lsquo;i&rsquo; in the cycle (note that node names depend on USENAME0), and &lsquo;ArcPred[ i ]&rsquo; contains the index of the arc joining the two (note that in general there may be multiple copies of each arc). Entries of the vectors for nodes not belonging to the cycle are in principle undefined, and the name of one node belonging to the cycle is returned by the method. Note that if there are multiple cycles with negative costs this method will return just one of them (finding the cycle with most negative cost is an NP-hard problem), although solvers should be able to produce cycles with "large negative" cost.</p>
<p>However, not all solvers may be (easily) capable of providing this information; thus, returning Inf&lt; Index &gt;() is allowed, as in the base class implementation, to signify that this information is not available. </p>

</div>
</div>
<a id="ae7465ca4be416c7bd49d496d86ccba46" name="ae7465ca4be416c7bd49d496d86ccba46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7465ca4be416c7bd49d496d86ccba46">&#9670;&#160;</a></span>MCFGetState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a> MCFGetState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>save the state of the MCF solver </p>
<p>Save the state of the MCF solver. The <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> interface supports the notion of saving and restoring the state of the MCF solver, such as the current/optimal basis in a simplex solver. The "empty" class <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass_1_1MCFState.html" title="Base class for representing the internal state of the MCF algorithm.">MCFState</a> is defined as a placeholder for state descriptions.</p>
<p><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ae7465ca4be416c7bd49d496d86ccba46" title="save the state of the MCF solver">MCFGetState()</a> creates and returns a pointer to an object of (a proper derived class of) class <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass_1_1MCFState.html" title="Base class for representing the internal state of the MCF algorithm.">MCFState</a> which describes the current state of the MCF solver. </p>

<p>Reimplemented in <a class="el" href="classMCFClass__di__unipi__it_1_1RelaxIV.html#afd52b0e6eb5a41e2bf065064fd8ea8e9">RelaxIV</a>.</p>

</div>
</div>
<a id="ac14589cd80aed231b6fc7da247f50601" name="ac14589cd80aed231b6fc7da247f50601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14589cd80aed231b6fc7da247f50601">&#9670;&#160;</a></span>MCFPutState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFPutState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a>&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>restore the state of the solver </p>
<p>Restore the solver to the state in which it was when the state &lsquo;S&rsquo; was created with <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ae7465ca4be416c7bd49d496d86ccba46" title="save the state of the MCF solver">MCFGetState()</a> [see above].</p>
<p>The typical use of this method is the following: a MCF problem is solved and the "optimal state" is set aside. Then the problem changes and it is re-solved. Then, the problem has to be changed again to a form that is close to the original one but rather different from the second one (think of a long backtracking in a Branch &amp; Bound) to which the current "state" referes. Then, the old optimal state can be expected to provide a better starting point for reoptimization [see ReOptimize() below].</p>
<p>Note, however, that the state is only relative to the optimization process, i.e., this operation is meaningless if the data of the problem has changed in the meantime. So, if a state has to be used for speeding up reoptimization, the following has to be done:</p>
<ul>
<li>first, the data of the solver is brought back to <em>exactly</em> the same as it was at the moment where the state &lsquo;S&rsquo; was created (prior than this operation a ReOptimize( false ) call is probably advisable);</li>
<li>then, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ac14589cd80aed231b6fc7da247f50601" title="restore the state of the solver">MCFPutState()</a> is called (and ReOptimize( true ) is called);</li>
<li>only afterwards the data of the problem is changed to the final state and the problem is solved.</li>
</ul>
<p>A "put state" operation does not "deplete" the state, which can therefore be used more than once. Indeed, a state is constructed inside the solver for each call to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ae7465ca4be416c7bd49d496d86ccba46" title="save the state of the MCF solver">MCFGetState()</a>, but the solver never deletes statuses; this has to be done on the outside when they are no longer needed (the solver must be "resistent" to deletion of the state at any moment).</p>
<p>Since not all the MCF solvers reoptimize (efficiently enough to make these operations worth), an "empty" implementation that does nothing is provided by the base class. </p>

</div>
</div>
<a id="ae30b2377d5464d44b234bcc44ceb2a6f" name="ae30b2377d5464d44b234bcc44ceb2a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30b2377d5464d44b234bcc44ceb2a6f">&#9670;&#160;</a></span>TimeMCF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TimeMCF </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t_ss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>time the code </p>
<p>Time the code. If called within any of the methods of the class that are "actively timed" (this depends on the subclasses), this method returns the user and sistem time (in seconds) since the start of that method. If methods that are actively timed call other methods that are actively timed, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a0c950787358582eb9038bd8f9dcfb070" title="Like TimeMCF( double , double ) [see above], but returns the total time.">TimeMCF()</a> returns the (...) time since the beginning of the outer* actively timed method. If called outside of any actively timed method, this method returns the (...) time spent in all the previous executions of all the actively timed methods of the class.</p>
<p>Implementing the proper calls to MCFt-&gt;Start() and MCFt-&gt;Stop() is due to derived classes; these should at least be placed at the beginning and at the end, respectively, of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ac0d96429d896a2d878a5f057535ab1ee" title="solve the problem">SolveMCF()</a> and presumably the Chg***() methods, that is, at least these methods should be "actively timed". </p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab7624a057d988dd8f61b038ff459cd0b">MCFClass::MCFt</a>, and <a class="el" href="classOPTtypes__di__unipi__it_1_1OPTtimers.html#af0ce31a284ab2dedf9cede10bc3ccce0">OPTtimers::Read()</a>.</p>

</div>
</div>
<a id="a7c8357e94656cea56777203f7d4345b2" name="a7c8357e94656cea56777203f7d4345b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8357e94656cea56777203f7d4345b2">&#9670;&#160;</a></span>CheckPSol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CheckPSol </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks the primal solution </p>
<p>Check that the primal solution returned by the solver is primal feasible. (to within the tolerances set by SetPar(kEps****), if any). Also, check that the objective function value is correct.</p>
<p>This method is implemented by the base class, using the above methods for collecting the solutions and the methods of the next section for reading the data of the problem; as such, they will work for any derived class that properly implements all these methods. </p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aad8c11b8ba9065dd3bc0f7b5ec423869">MCFClass::EpsCst</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9159ee7ca50477fd57f6854ff73b2874">MCFClass::EpsDfct</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a65b1c456efbc2e544b82cb6553f6df8d">MCFClass::EpsFlw</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a260ef7a8885fdffab5638a8200a6ee11">MCFClass::ETZ()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aac4497a2714ac9b23506c1beacfb9e32">MCFClass::GT()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa44ede948e50793bc69c9ce50e3ff862">MCFClass::GTZ()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a90a46e52b3d48c27536b745750e82dd6">MCFClass::IsClosedArc()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#acabd37f04b963a582caeb36966f8affd">MCFClass::LTZ()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6e34001e506e91ae6f8f1609afb8cfa0">MCFClass::MCFCost()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab069987c4ba513e98364780e8807f739">MCFClass::MCFDfcts()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a321ee5226247ff7f16e93b5e2e55a4dd">MCFClass::MCFENde()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8fa24610af25b480e674fd71aa941ecd">MCFClass::MCFGetFO()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a76b0e00ff4baafb00ff03e213ca83dbd">MCFClass::MCFGetX()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82">MCFClass::MCFm()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1aa06580ba205fe81a2032afa980da82">MCFClass::MCFn()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a0fe2e1c0ed569cdcac2ea817c9e15db6">MCFClass::MCFQCoef()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a4a89759c70e6df8a37ad7d915fd873bc">MCFClass::MCFSNde()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7cb7ef61fd8db9082b46b938bd0c35ed">MCFClass::MCFUCap()</a>.</p>

</div>
</div>
<a id="a87f68e5fc8390d9fa6e4c1ff6552df0c" name="a87f68e5fc8390d9fa6e4c1ff6552df0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f68e5fc8390d9fa6e4c1ff6552df0c">&#9670;&#160;</a></span>CheckDSol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CheckDSol </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks the dual solution </p>
<p>Check that the dual solution returned by the solver is dual feasible. (to within the tolerances set by SetPar(kEps****), if any). Also, check that the objective function value is correct.</p>
<p>This method is implemented by the base class, using the above methods for collecting the solutions and the methods of the next section for reading the data of the problem; as such, they will work for any derived class that properly implements all these methods. </p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aad8c11b8ba9065dd3bc0f7b5ec423869">MCFClass::EpsCst</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a65b1c456efbc2e544b82cb6553f6df8d">MCFClass::EpsFlw</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a260ef7a8885fdffab5638a8200a6ee11">MCFClass::ETZ()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa44ede948e50793bc69c9ce50e3ff862">MCFClass::GTZ()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a90a46e52b3d48c27536b745750e82dd6">MCFClass::IsClosedArc()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aef480b236190ea4dc5350ba0a41af10b">MCFClass::LT()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#acabd37f04b963a582caeb36966f8affd">MCFClass::LTZ()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6e34001e506e91ae6f8f1609afb8cfa0">MCFClass::MCFCost()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aae6b79b9254d345c15b83ac30885fd3e">MCFClass::MCFDfct()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a321ee5226247ff7f16e93b5e2e55a4dd">MCFClass::MCFENde()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a8fa24610af25b480e674fd71aa941ecd">MCFClass::MCFGetFO()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9589c18168466325844bc8d43ab60518">MCFClass::MCFGetPi()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aef9fe72baa305e432331d4f7e98f6b2c">MCFClass::MCFGetRC()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a76b0e00ff4baafb00ff03e213ca83dbd">MCFClass::MCFGetX()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82">MCFClass::MCFm()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1aa06580ba205fe81a2032afa980da82">MCFClass::MCFn()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a0fe2e1c0ed569cdcac2ea817c9e15db6">MCFClass::MCFQCoef()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a4a89759c70e6df8a37ad7d915fd873bc">MCFClass::MCFSNde()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7cb7ef61fd8db9082b46b938bd0c35ed">MCFClass::MCFUCap()</a>.</p>

</div>
</div>
<a id="a4630f116b2dc9f80359df6e4ef9649ca" name="a4630f116b2dc9f80359df6e4ef9649ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4630f116b2dc9f80359df6e4ef9649ca">&#9670;&#160;</a></span>MCFnmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFnmax </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximum number of nodes </p>
<p>Return the maximum number of nodes for this instance of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a>. The implementation of the method in the base class returns the protected fields <code>nmax</code>, which is provided for derived classes to hold this information. </p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a02366e13d56b1124db9bf8281b73ca9a">MCFClass::nmax</a>.</p>

</div>
</div>
<a id="a139c737142980169abf4179c1a1dee25" name="a139c737142980169abf4179c1a1dee25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139c737142980169abf4179c1a1dee25">&#9670;&#160;</a></span>MCFmmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFmmax </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximum number of arcs </p>
<p>Return the maximum number of arcs for this instance of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a>. The implementation of the method in the base class returns the protected fields <code>mmax</code>, which is provided for derived classes to hold this information. </p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a93e7022437bc38dc11cffe32d4b2332c">MCFClass::mmax</a>.</p>

</div>
</div>
<a id="a1aa06580ba205fe81a2032afa980da82" name="a1aa06580ba205fe81a2032afa980da82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa06580ba205fe81a2032afa980da82">&#9670;&#160;</a></span>MCFn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the current number of nodes </p>
<p>Return the number of nodes in the current graph. The implementation of the method in the base class returns the protected fields <code>n</code>, which is provided for derived classes to hold this information. </p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7f0f8bcc88c30609d766a4e723a53dac">MCFClass::n</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87f68e5fc8390d9fa6e4c1ff6552df0c">MCFClass::CheckDSol()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7c8357e94656cea56777203f7d4345b2">MCFClass::CheckPSol()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6afe6fc886cba0606b766cf14b3d4fca">MCFClass::WriteMCF()</a>.</p>

</div>
</div>
<a id="a572d5627356cb68d1dc654d0da000c82" name="a572d5627356cb68d1dc654d0da000c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572d5627356cb68d1dc654d0da000c82">&#9670;&#160;</a></span>MCFm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFm </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the current number of arcs </p>
<p>Return the number of arcs in the current graph. The implementation of the method in the base class returns the protected fields <code>m</code>, which is provided for derived classes to hold this information. </p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a61d50257929003fb000e6bcc1db02fd6">MCFClass::m</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87f68e5fc8390d9fa6e4c1ff6552df0c">MCFClass::CheckDSol()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7c8357e94656cea56777203f7d4345b2">MCFClass::CheckPSol()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6afe6fc886cba0606b766cf14b3d4fca">MCFClass::WriteMCF()</a>.</p>

</div>
</div>
<a id="aa2830a07595970284ee05117c621abfc" name="aa2830a07595970284ee05117c621abfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2830a07595970284ee05117c621abfc">&#9670;&#160;</a></span>MCFArcs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFArcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>Startv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>Endv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the starting and ending nodes in vectors </p>
<p>Write the starting (tail) and ending (head) nodes of the arcs in Startv[] and Endv[]. If nms == 0, then the information relative to all arcs is written into Startv[] and Endv[], otherwise Startv[ i ] and Endv[ i ] contain the information relative to arc nms[ i ] (nms[] must be Inf&lt; Index &gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms and whose index is in the correct range are returned.</p>
<p>Startv or Endv can be 0, meaning that only the other information is required.</p>
<dl class="section note"><dt>Note</dt><dd>If USENAME0 == 0 then the returned node names will be in the range 1 .. n, while if USENAME0 == 1 the returned node names will be in the range 0 .. n - 1.</dd>
<dd>
If the graph is "dynamic", be careful to use <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1aa06580ba205fe81a2032afa980da82" title="return the current number of nodes">MCFn()</a> e <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82" title="return the current number of arcs">MCFm()</a> to properly choose the dimension of nodes and arcs arrays. </dd></dl>

</div>
</div>
<a id="a4a89759c70e6df8a37ad7d915fd873bc" name="a4a89759c70e6df8a37ad7d915fd873bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a89759c70e6df8a37ad7d915fd873bc">&#9670;&#160;</a></span>MCFSNde()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFSNde </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the starting (tail) node of the arc &lsquo;i&rsquo; </p>
<p>Return the starting (tail) node of the arc &lsquo;i&rsquo;.</p>
<dl class="section note"><dt>Note</dt><dd>If USENAME0 == 0 then the returned node names will be in the range 1 .. n, while if USENAME0 == 1 the returned node names will be in the range 0 .. n - 1. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87f68e5fc8390d9fa6e4c1ff6552df0c">MCFClass::CheckDSol()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7c8357e94656cea56777203f7d4345b2">MCFClass::CheckPSol()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6afe6fc886cba0606b766cf14b3d4fca">MCFClass::WriteMCF()</a>.</p>

</div>
</div>
<a id="a321ee5226247ff7f16e93b5e2e55a4dd" name="a321ee5226247ff7f16e93b5e2e55a4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321ee5226247ff7f16e93b5e2e55a4dd">&#9670;&#160;</a></span>MCFENde()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFENde </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the ending (head) node of the arc &lsquo;i&rsquo; </p>
<p>Return the ending (head) node of the arc &lsquo;i&rsquo;.</p>
<dl class="section note"><dt>Note</dt><dd>If USENAME0 == 0 then the returned node names will be in the range 1 .. n, while if USENAME0 == 1 the returned node names will be in the range 0 .. n - 1. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87f68e5fc8390d9fa6e4c1ff6552df0c">MCFClass::CheckDSol()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7c8357e94656cea56777203f7d4345b2">MCFClass::CheckPSol()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6afe6fc886cba0606b766cf14b3d4fca">MCFClass::WriteMCF()</a>.</p>

</div>
</div>
<a id="a6584ec304a6ee6c9ff057e4f83bf6651" name="a6584ec304a6ee6c9ff057e4f83bf6651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6584ec304a6ee6c9ff057e4f83bf6651">&#9670;&#160;</a></span>MCFSNdes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> MCFSNdes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a read-only pointer to the vector of starting nodes </p>
<p>Return a read-only pointer to an internal vector containing the starting (tail) nodes for each arc. Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classMCFClass__di__unipi__it_1_1RelaxIV.html#a735fc35ea35c569f85fc39c64c3f9446">RelaxIV</a>.</p>

</div>
</div>
<a id="a53fe0ee1951e62add38185a24f6fe719" name="a53fe0ee1951e62add38185a24f6fe719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fe0ee1951e62add38185a24f6fe719">&#9670;&#160;</a></span>MCFENdes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> MCFENdes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a read-only pointer to the vector of ending nodes </p>
<p>Return a read-only pointer to an internal vector containing the ending (head) nodes for each arc. Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classMCFClass__di__unipi__it_1_1RelaxIV.html#a25c6929889f9aa2abc04bdfbd9c0e8e0">RelaxIV</a>.</p>

</div>
</div>
<a id="aeaaded5485711ad33d95376a97eb55c7" name="aeaaded5485711ad33d95376a97eb55c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaaded5485711ad33d95376a97eb55c7">&#9670;&#160;</a></span>MCFCosts() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFCosts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>Costv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the arc costs into a vector </p>
<p>Write the arc costs into Costv[]. If nms == 0, then all the costs are written, otherwise Costv[ i ] contains the information relative to arc nms[ i ] (nms[] must be Inf&lt; Index &gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms and whose index is in the correct range are returned. </p>

</div>
</div>
<a id="a9beabbcc03bc333ba2ec0e0072e4dfb3" name="a9beabbcc03bc333ba2ec0e0072e4dfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9beabbcc03bc333ba2ec0e0072e4dfb3">&#9670;&#160;</a></span>MCFCosts() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> MCFCosts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a read-only pointer to the vector of arc costs </p>
<p>Return a read-only pointer to an internal vector containing the arc costs. Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

</div>
</div>
<a id="abdd114e9f6e70cb2a0dc4259af4d0d9f" name="abdd114e9f6e70cb2a0dc4259af4d0d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd114e9f6e70cb2a0dc4259af4d0d9f">&#9670;&#160;</a></span>MCFQCoef() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>Qv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the quadratic coefficients of the arc costs into a vector </p>
<p>Write the quadratic coefficients of the arc costs into Qv[]. If nms == 0, then all the costs are written, otherwise Costv[ i ] contains the information relative to arc nms[ i ] (nms[] must be Inf&lt; Index &gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms and whose index is in the correct range are returned.</p>
<p>Note that the method is <em>not</em> pure virtual: an implementation is provided for "pure linear" MCF solvers that only work with all zero quadratic coefficients. </p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a61d50257929003fb000e6bcc1db02fd6">MCFClass::m</a>.</p>

</div>
</div>
<a id="af54237130edd37b17ad9032b8b85ac7e" name="af54237130edd37b17ad9032b8b85ac7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54237130edd37b17ad9032b8b85ac7e">&#9670;&#160;</a></span>MCFQCoef() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> MCFQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the quadratic coefficients of the cost of the i-th arc </p>
<p>Return the quadratic coefficients of the cost of the i-th arc. Note that the method is <em>not</em> pure virtual: an implementation is provided for "pure
linear" MCF solvers that only work with all zero quadratic coefficients. </p>

</div>
</div>
<a id="a0fe2e1c0ed569cdcac2ea817c9e15db6" name="a0fe2e1c0ed569cdcac2ea817c9e15db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe2e1c0ed569cdcac2ea817c9e15db6">&#9670;&#160;</a></span>MCFQCoef() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> MCFQCoef </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a read-only pointer to the vector of arc quadratic costs </p>
<p>Return a read-only pointer to an internal vector containing the arc costs. Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready (such as "pure linear" MCF solvers that only work with all zero quadratic coefficients) does not need to implement the method. </p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87f68e5fc8390d9fa6e4c1ff6552df0c">MCFClass::CheckDSol()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7c8357e94656cea56777203f7d4345b2">MCFClass::CheckPSol()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6afe6fc886cba0606b766cf14b3d4fca">MCFClass::WriteMCF()</a>.</p>

</div>
</div>
<a id="acaa36d21d8df9e1d85849ab796d4b9ca" name="acaa36d21d8df9e1d85849ab796d4b9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa36d21d8df9e1d85849ab796d4b9ca">&#9670;&#160;</a></span>MCFUCaps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFUCaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>UCapv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the arc capacities into a vector </p>
<p>Write the arc capacities into UCapv[]. If nms == 0, then all the capacities are written, otherwise UCapv[ i ] contains the information relative to arc nms[ i ] (nms[] must be Inf&lt; Index &gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms and whose index is in the correct range are returned. </p>

</div>
</div>
<a id="afd0781725626c581e345cfb2354ca48b" name="afd0781725626c581e345cfb2354ca48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0781725626c581e345cfb2354ca48b">&#9670;&#160;</a></span>MCFUCaps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> MCFUCaps </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a read-only pointer to an the vector of arc capacities </p>
<p>Return a read-only pointer to an internal vector containing the arc capacities. Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

</div>
</div>
<a id="a4c6c9bad12327221a39f9ed312f7958b" name="a4c6c9bad12327221a39f9ed312f7958b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6c9bad12327221a39f9ed312f7958b">&#9670;&#160;</a></span>MCFDfcts() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFDfcts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>Dfctv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the node deficits into a vector </p>
<p>Write the node deficits into Dfctv[]. If nms == 0, then all the defcits are written, otherwise Dfctvv[ i ] contains the information relative to node nms[ i ] (nms[] must be Inf&lt; Index &gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the nodes &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFn() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to nodes which are <em>both</em> in nms and whose index is in the correct range are returned.</p>
<dl class="section note"><dt>Note</dt><dd>Here node "names" (strt and stp, those contained in nms[] or &lsquo;i&rsquo; in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aae6b79b9254d345c15b83ac30885fd3e" title="return the deficit of the i-th node">MCFDfct()</a>) go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit is returned by MCFDfcts( Dfctv , 0 , 0 , 1 ). </dd></dl>

</div>
</div>
<a id="aae6b79b9254d345c15b83ac30885fd3e" name="aae6b79b9254d345c15b83ac30885fd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6b79b9254d345c15b83ac30885fd3e">&#9670;&#160;</a></span>MCFDfct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> MCFDfct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the deficit of the i-th node </p>
<p>Return the deficit of the i-th node.</p>
<dl class="section note"><dt>Note</dt><dd>Here node "names" go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit is returned by MCFDfct( 0 ). </dd></dl>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a87f68e5fc8390d9fa6e4c1ff6552df0c">MCFClass::CheckDSol()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6afe6fc886cba0606b766cf14b3d4fca">MCFClass::WriteMCF()</a>.</p>

</div>
</div>
<a id="ab069987c4ba513e98364780e8807f739" name="ab069987c4ba513e98364780e8807f739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab069987c4ba513e98364780e8807f739">&#9670;&#160;</a></span>MCFDfcts() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> MCFDfcts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a read-only pointer to the vector of node deficits </p>
<p>Return a read-only pointer to an internal vector containing the node deficits. Since this may <em>not always be available</em>, depending on the implementation, this method can (uniformly) return 0. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method.</p>
<dl class="section note"><dt>Note</dt><dd>Here node "names" go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit is contained in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab069987c4ba513e98364780e8807f739" title="return a read-only pointer to the vector of node deficits">MCFDfcts()</a>[ 0 ]. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7c8357e94656cea56777203f7d4345b2">MCFClass::CheckPSol()</a>.</p>

</div>
</div>
<a id="a6afe6fc886cba0606b766cf14b3d4fca" name="a6afe6fc886cba0606b766cf14b3d4fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afe6fc886cba0606b766cf14b3d4fca">&#9670;&#160;</a></span>WriteMCF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WriteMCF </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>oStrm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frmt</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the current MCF problem to an ostream </p>
<p>Write the current MCF problem to an ostream. This may be useful e.g. for debugging purposes.</p>
<p>The base <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> class provides output in two different formats, depending on the value of the parameter frmt:</p>
<ul>
<li>kDimacs the problem is written in DIMACS standard format, read by most MCF codes available;</li>
<li>kMPS the problem is written in the "modern version" (tab-separated) of the MPS format, read by most LP/MIP solvers;<ul>
<li>kFWMPS the problem is written in the "old version" (fixed width fields) of the MPS format; this is read by most LP/MIP solvers, but some codes still require the old format.</li>
</ul>
</li>
</ul>
<p>The implementation of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6afe6fc886cba0606b766cf14b3d4fca" title="write the current MCF problem to an ostream">WriteMCF()</a> in the base class uses all the above methods for reading the data; as such it will work for any derived class that properly implements this part of the interface, but it may not be very efficient. Thus, the method is virtual to allow the derived classes to either re-implement <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6afe6fc886cba0606b766cf14b3d4fca" title="write the current MCF problem to an ostream">WriteMCF()</a> for the above two formats in a more efficient way, and/or to extend it to support other solver-specific formats.</p>
<dl class="section note"><dt>Note</dt><dd>None of the above two formats supports quadratic MCFs, so if nonzero quadratic coefficients are present, they are just ignored. </dd></dl>

<p>Reimplemented in <a class="el" href="classMCFClass__di__unipi__it_1_1RelaxIV.html#a73d84f4d5e0d8c71927b73c0cf3edde9">RelaxIV</a>.</p>

<p class="reference">References <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a90a46e52b3d48c27536b745750e82dd6">MCFClass::IsClosedArc()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7682b19c9163c24d66af23071791de64">MCFClass::IsDeletedArc()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#adb1b139bac65f5f35bdadc7549a819dea6e65d07cdd719be7d99902bb47920a37">MCFClass::kDimacs</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#adb1b139bac65f5f35bdadc7549a819dea7efb98d1b3dfca0f601d4df644b418a0">MCFClass::kFWMPS</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#adb1b139bac65f5f35bdadc7549a819dea65125719fd6c68bc3904a45937fcfd85">MCFClass::kMPS</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#adb1b139bac65f5f35bdadc7549a819deac27a029d7010490d53e1df36b39597e6">MCFClass::kQDimacs</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6e34001e506e91ae6f8f1609afb8cfa0">MCFClass::MCFCost()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aae6b79b9254d345c15b83ac30885fd3e">MCFClass::MCFDfct()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a321ee5226247ff7f16e93b5e2e55a4dd">MCFClass::MCFENde()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82">MCFClass::MCFm()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1aa06580ba205fe81a2032afa980da82">MCFClass::MCFn()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a0fe2e1c0ed569cdcac2ea817c9e15db6">MCFClass::MCFQCoef()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a4a89759c70e6df8a37ad7d915fd873bc">MCFClass::MCFSNde()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a7cb7ef61fd8db9082b46b938bd0c35ed">MCFClass::MCFUCap()</a>, and <a class="el" href="group__MCFCLASS__MACROS.html#ga74cc96ffa32533b7eff040b5ffee5e06">USENAME0</a>.</p>

</div>
</div>
<a id="a9d8aca3dbd796c03525e503a8aaa71bb" name="a9d8aca3dbd796c03525e503a8aaa71bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8aca3dbd796c03525e503a8aaa71bb">&#9670;&#160;</a></span>ChgCosts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgCosts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>NCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change the arc costs </p>
<p>Change the arc costs. In particular, change the costs that are:</p>
<ul>
<li>listed in into the vector of indices &lsquo;nms&rsquo; (ordered in increasing sense and Inf&lt; Index &gt;()-terminated),</li>
<li><em>and</em> whose name belongs to the interval [&lsquo;strt&rsquo;, &lsquo;stp&rsquo;).</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th cost will be changed to NCost[ i ]. If nms == 0 (as the default), <em>all</em> the entries in the given range will be changed; if stp &gt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82" title="return the current number of arcs">MCFm()</a>, then the smaller bound is used.</p>
<dl class="section note"><dt>Note</dt><dd>changing the costs of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs which have not been closed/deleted [see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa71f643926bec5b0634f66d112704205" title="&quot;close&quot; one arc">CloseArc()</a> / <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa7de6dac2b157eef88ea0bc55bc1f887" title="deletes one arc">DelArc()</a> below and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9" title="inputs a new network from memory">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="ac731ea9479f870dca111ba07a6d58a3f" name="ac731ea9479f870dca111ba07a6d58a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac731ea9479f870dca111ba07a6d58a3f">&#9670;&#160;</a></span>ChgCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td>
          <td class="paramname"><em>NCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change the cost of the i-th arc </p>
<p>Change the cost of the i-th arc.</p>
<dl class="section note"><dt>Note</dt><dd>changing the costs of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs which have not been closed/deleted [see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa71f643926bec5b0634f66d112704205" title="&quot;close&quot; one arc">CloseArc()</a> / <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa7de6dac2b157eef88ea0bc55bc1f887" title="deletes one arc">DelArc()</a> below and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9" title="inputs a new network from memory">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="a1a55e6b1dda20d5835b0a162f80463ac" name="a1a55e6b1dda20d5835b0a162f80463ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a55e6b1dda20d5835b0a162f80463ac">&#9670;&#160;</a></span>ChgQCoef() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>NQCoef</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change the quadratic coefficients of the arc costs </p>
<p>Change the quadratic coefficients of the arc costs. In particular, change the coefficients that are:</p>
<ul>
<li>listed in into the vector of indices &lsquo;nms&rsquo; (ordered in increasing sense and Inf&lt; Index &gt;()-terminated),</li>
<li><em>and</em> whose name belongs to the interval [&lsquo;strt&rsquo;, &lsquo;stp&rsquo;).</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th cost will be changed to NCost[ i ]. If nms == 0 (as the default), <em>all</em> the entries in the given range will be changed; if stp &gt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82" title="return the current number of arcs">MCFm()</a>, then the smaller bound is used. If NQCoef == 0, all the specified coefficients are set to zero.</p>
<p>Note that the method is <em>not</em> pure virtual: an implementation is provided for "pure linear" MCF solvers that only work with all zero quadratic coefficients.</p>
<dl class="section note"><dt>Note</dt><dd>changing the costs of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs which have not been closed/deleted [see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa71f643926bec5b0634f66d112704205" title="&quot;close&quot; one arc">CloseArc()</a> / <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa7de6dac2b157eef88ea0bc55bc1f887" title="deletes one arc">DelArc()</a> below and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9" title="inputs a new network from memory">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a34d79a2f00cf8a2416b2b3e41552e843">MCFClass::LoadDMX()</a>.</p>

</div>
</div>
<a id="ab378af205999614b6d92612b005f4189" name="ab378af205999614b6d92612b005f4189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab378af205999614b6d92612b005f4189">&#9670;&#160;</a></span>ChgQCoef() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td>
          <td class="paramname"><em>NQCoef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change the quadratic coefficient of the cost of the i-th arc </p>
<p>Change the quadratic coefficient of the cost of the i-th arc.</p>
<p>Note that the method is <em>not</em> pure virtual: an implementation is provided for "pure linear" MCF solvers that only work with all zero quadratic coefficients.</p>
<dl class="section note"><dt>Note</dt><dd>changing the costs of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs which have not been closed/deleted [see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa71f643926bec5b0634f66d112704205" title="&quot;close&quot; one arc">CloseArc()</a> / <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa7de6dac2b157eef88ea0bc55bc1f887" title="deletes one arc">DelArc()</a> below and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9" title="inputs a new network from memory">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="aab838755daac0e0355e872f996f8cc0d" name="aab838755daac0e0355e872f996f8cc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab838755daac0e0355e872f996f8cc0d">&#9670;&#160;</a></span>ChgUCaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgUCaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>NCap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change the arc capacities </p>
<p>Change the arc capacities. In particular, change the capacities that are:</p>
<ul>
<li>listed in into the vector of indices &lsquo;nms&rsquo; (ordered in increasing sense and Inf&lt; Index &gt;()-terminated),</li>
<li><em>and</em> whose name belongs to the interval [&lsquo;strt&rsquo;, &lsquo;stp&rsquo;).</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th capacity will be changed to NCap[ i ]. If nms == 0 (as the default), <em>all</em> the entries in the given range will be changed; if stp &gt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82" title="return the current number of arcs">MCFm()</a>, then the smaller bound is used.</p>
<dl class="section note"><dt>Note</dt><dd>changing the capacities of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs that have not been closed/deleted [see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa71f643926bec5b0634f66d112704205" title="&quot;close&quot; one arc">CloseArc()</a> / <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa7de6dac2b157eef88ea0bc55bc1f887" title="deletes one arc">DelArc()</a> below and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9" title="inputs a new network from memory">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="abfdb302f0b1350bb545420c18752839a" name="abfdb302f0b1350bb545420c18752839a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfdb302f0b1350bb545420c18752839a">&#9670;&#160;</a></span>ChgUCap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgUCap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td>
          <td class="paramname"><em>NCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change the capacity of the i-th arc </p>
<p>Change the capacity of the i-th arc.</p>
<dl class="section note"><dt>Note</dt><dd>changing the capacities of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs that have not been closed/deleted [see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa71f643926bec5b0634f66d112704205" title="&quot;close&quot; one arc">CloseArc()</a> / <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa7de6dac2b157eef88ea0bc55bc1f887" title="deletes one arc">DelArc()</a> below and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa55a46d5b60df521c30da61e222f6da9" title="inputs a new network from memory">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="a3fe9ca77701d03d772fcaf0c5817ded3" name="a3fe9ca77701d03d772fcaf0c5817ded3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe9ca77701d03d772fcaf0c5817ded3">&#9670;&#160;</a></span>ChgDfcts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgDfcts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>NDfct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change the node deficits </p>
<p>Change the node deficits. In particular, change the deficits that are:</p>
<ul>
<li>listed in into the vector of indices &lsquo;nms&rsquo; (ordered in increasing sense and Inf&lt; Index &gt;()-terminated),</li>
<li><em>and</em> whose name belongs to the interval [&lsquo;strt&rsquo;, &lsquo;stp&rsquo;).</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th deficit will be changed to NDfct[ i ]. If nms == 0 (as the default), <em>all</em> the entries in the given range will be changed; if stp &gt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1aa06580ba205fe81a2032afa980da82" title="return the current number of nodes">MCFn()</a>, then the smaller bound is used.</p>
<p>Note that, in <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a3fe9ca77701d03d772fcaf0c5817ded3" title="change the node deficits">ChgDfcts()</a>, node "names" (strt, stp or those contained in nms[]) go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit can be changed e.g. with ChgDfcts( &amp;new_deficit , 0 , 0 , 1 ).</p>
<dl class="section note"><dt>Note</dt><dd>changing the deficits of nodes that <em>do not exist</em> is <em>not allowed</em>; only nodes that have not been deleted [see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a4e935c4f233322c893e1e3630b70f465" title="delete one node">DelNode()</a> below] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="a4512c7e365110863c5ef90854ceebfdc" name="a4512c7e365110863c5ef90854ceebfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4512c7e365110863c5ef90854ceebfdc">&#9670;&#160;</a></span>ChgDfct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgDfct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td>
          <td class="paramname"><em>NDfct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change the deficit of the i-th node </p>
<p>Change the deficit of the i-th node.</p>
<p>Note that the node "name" i go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit can be changed e.g. with ChgDfcts( 0 , new_deficit ).</p>
<dl class="section note"><dt>Note</dt><dd>changing the deficits of nodes that <em>do not exist</em> is <em>not allowed</em>; only nodes that have not been deleted [see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a4e935c4f233322c893e1e3630b70f465" title="delete one node">DelNode()</a> below] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="aa71f643926bec5b0634f66d112704205" name="aa71f643926bec5b0634f66d112704205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71f643926bec5b0634f66d112704205">&#9670;&#160;</a></span>CloseArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CloseArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"close" one arc </p>
<p>"Close" the arc &lsquo;name&rsquo;. Although all the associated information (name, cost, capacity, end and start node) is kept, the arc is removed from the problem until OpenArc( i ) [see below] is called.</p>
<p>"closed" arcs always have 0 flow, but are otherwise counted as any other arc; for instance, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82" title="return the current number of arcs">MCFm()</a> does <em>not</em> decrease as an effect of a call to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa71f643926bec5b0634f66d112704205" title="&quot;close&quot; one arc">CloseArc()</a>. How this closure is implemented is solver-specific. </p>

</div>
</div>
<a id="a4e935c4f233322c893e1e3630b70f465" name="a4e935c4f233322c893e1e3630b70f465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e935c4f233322c893e1e3630b70f465">&#9670;&#160;</a></span>DelNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DelNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delete one node </p>
<p>Delete the node &lsquo;name&rsquo;.</p>
<p>For any value of &lsquo;name&rsquo;, all incident arcs to that node are closed [see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa71f643926bec5b0634f66d112704205" title="&quot;close&quot; one arc">CloseArc()</a> above] (<em>not</em> Deleted, see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa7de6dac2b157eef88ea0bc55bc1f887" title="deletes one arc">DelArc()</a> below) and the deficit is set to zero.</p>
<p>Note that deleting a node leaves a "hole" in the set of node names: the number of nodes as reported by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1aa06580ba205fe81a2032afa980da82" title="return the current number of nodes">MCFn()</a> remains the same (save for the case described next). No attempt at keeping a consecutive set of valid node names is done: if this is important, it's the user who have to work towards such a goal by "moving" nodes, i.e., deleting and re-adding them, see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a3b39d6d4a8938d7ea99dd9d6ef173422" title="adds a ned node">AddNode()</a>. The only exception is if &lsquo;name&rsquo; here is the last node; in this case the number of nodes as reported by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1aa06580ba205fe81a2032afa980da82" title="return the current number of nodes">MCFn()</a> is reduced by at least one, until the n-th node is not a deleted one. </p>

</div>
</div>
<a id="a8e6eb03b7e44dbc8b8b845ac3fa7632a" name="a8e6eb03b7e44dbc8b8b845ac3fa7632a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6eb03b7e44dbc8b8b845ac3fa7632a">&#9670;&#160;</a></span>OpenArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OpenArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>re-opens a closed arc </p>
<p>Restore the previously closed arc &lsquo;name&rsquo;. It is an error to open an arc that has not been previously closed. </p>

</div>
</div>
<a id="a3b39d6d4a8938d7ea99dd9d6ef173422" name="a3b39d6d4a8938d7ea99dd9d6ef173422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b39d6d4a8938d7ea99dd9d6ef173422">&#9670;&#160;</a></span>AddNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> AddNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td>
          <td class="paramname"><em>aDfct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adds a ned node </p>
<p>Add a new node with deficit aDfct, returning its name. Inf&lt; Index &gt;() is returned if there is no room for a new node. Remember that the node names are either { 0 .. nmax - 1 } or { 1 .. nmax }, depending on the value of USENAME0.</p>
<p>The handling of the set of node names should be arranged in a way that "tries as much as possible to have a consecutive set of small names
without trying to hard". That is, if there are no deleted nodes (see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a4e935c4f233322c893e1e3630b70f465" title="delete one node">DelNode()</a>), then the new node name will be <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1aa06580ba205fe81a2032afa980da82" title="return the current number of nodes">MCFn()</a> + 1, with <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1aa06580ba205fe81a2032afa980da82" title="return the current number of nodes">MCFn()</a> being the value prior to the call, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1aa06580ba205fe81a2032afa980da82" title="return the current number of nodes">MCFn()</a> increasing by one after the call. If, instead, there are deleted nodes, then the new node name will be the name of the currently deleted node with smaller name, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1aa06580ba205fe81a2032afa980da82" title="return the current number of nodes">MCFn()</a> will remain the same. </p>

</div>
</div>
<a id="aaab644a7aaaf652ee7dfc372831d10ce" name="aaab644a7aaaf652ee7dfc372831d10ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab644a7aaaf652ee7dfc372831d10ce">&#9670;&#160;</a></span>ChangeArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChangeArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>nSN</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>nEN</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change the starting and/or ending node of one arc </p>
<p>Change the starting and/or ending node of arc &lsquo;name&rsquo; to nSN and nEN. Each parameter being Inf&lt; Index &gt;() means to leave the previous starting or ending node untouched. When this method is called &lsquo;name&rsquo; can be either the name of a "normal" arc or that of a "closed" arc [see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa71f643926bec5b0634f66d112704205" title="&quot;close&quot; one arc">CloseArc()</a> above]: in the latter case, at the end of <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aaab644a7aaaf652ee7dfc372831d10ce" title="change the starting and/or ending node of one arc">ChangeArc()</a> the arc is <em>still closed</em>, and it remains so until OpenArc( name ) [see above] is called. </p>

</div>
</div>
<a id="aa7de6dac2b157eef88ea0bc55bc1f887" name="aa7de6dac2b157eef88ea0bc55bc1f887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7de6dac2b157eef88ea0bc55bc1f887">&#9670;&#160;</a></span>DelArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DelArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deletes one arc </p>
<p>Delete the arc &lsquo;name&rsquo;. Unlike "closed" arcs, all the information associated with a deleted arc is lost and &lsquo;name&rsquo; is made available as a name for new arcs to be created with <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a0edfad62b2d73be9e079fc521fff0c1b" title="adds a new arc">AddArc()</a> [see below].</p>
<p>Note that deleting an arc leaves a "hole" in the set of node arcs: the number of arcs as reported by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82" title="return the current number of arcs">MCFm()</a> remains the same (save for the case described next). No attempt at keeping a consecutive set of valid arc names is done: if this is important, it's the user who have to work towards such a goal by "moving" arcs, i.e., deleting and re-adding them, see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a0edfad62b2d73be9e079fc521fff0c1b" title="adds a new arc">AddArc()</a>. The only exception is if &lsquo;name&rsquo; here is the last arc; in this case the number of arcs as reported by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82" title="return the current number of arcs">MCFm()</a> is reduced by at least one, until the m-th arc is not a deleted one. </p>

</div>
</div>
<a id="a7682b19c9163c24d66af23071791de64" name="a7682b19c9163c24d66af23071791de64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7682b19c9163c24d66af23071791de64">&#9670;&#160;</a></span>IsDeletedArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsDeletedArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return true if and only if the arc is deleted </p>
<p>Return true if and only if the arc &lsquo;name&rsquo; is deleted. It should only be called with name &lt; <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82" title="return the current number of arcs">MCFm()</a>, as every other arc is deleted by definition. Note that a deleted arc is not closed, and vice-versa: to be closed an arc must exist, i.e., not be deleted. </p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a6afe6fc886cba0606b766cf14b3d4fca">MCFClass::WriteMCF()</a>.</p>

</div>
</div>
<a id="a0edfad62b2d73be9e079fc521fff0c1b" name="a0edfad62b2d73be9e079fc521fff0c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edfad62b2d73be9e079fc521fff0c1b">&#9670;&#160;</a></span>AddArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> AddArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td>
          <td class="paramname"><em>aU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td>
          <td class="paramname"><em>aC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adds a new arc </p>
<p>Add the new arc ( Start , End ) with cost aC and capacity aU, returning its name. Inf&lt; Index &gt;() is returned if there is no room for a new arc. Remember that arc names go from 0 to mmax - 1.</p>
<p>The handling of the set of arc names should be arranged in a way that "tries as much as possible to have a consecutive set of small names
without trying to hard". That is, if there are no deleted arcs (see <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#aa7de6dac2b157eef88ea0bc55bc1f887" title="deletes one arc">DelArc()</a>), then the new node name will be <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82" title="return the current number of arcs">MCFm()</a> + 1, with <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82" title="return the current number of arcs">MCFm()</a> being the value prior to the call, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82" title="return the current number of arcs">MCFm()</a> increasing by one after the call. If, instead, there are deleted nodes, then the new arc name will be the name of the currently deleted arc with smaller name, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a572d5627356cb68d1dc654d0da000c82" title="return the current number of arcs">MCFm()</a> will remain the same. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6e27f49150e9a14580fb313cc2777e00" name="a6e27f49150e9a14580fb313cc2777e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e27f49150e9a14580fb313cc2777e00">&#9670;&#160;</a></span>status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int status</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return status, see the comments to <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8" title="returns the solution status">MCFGetStatus()</a> above. </p>
<p>Note that the variable is defined int to allow derived classes to return their own specialized status codes </p>

<p class="reference">Referenced by <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a52812a5637b5bef5b6168f7bd062aa86">MCFClass::MCFClass()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a03701bebeaaf83d06f9d42a84ab92fd8">MCFClass::MCFGetStatus()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1SPTree.html#a8d2a9bf668f47f18759c37720248e5ab">SPTree::SetDest()</a>, <a class="el" href="classMCFClass__di__unipi__it_1_1SPTree.html#a5d2f0e220186b1b20d6890b645b61d0b">SPTree::SetOrigin()</a>, and <a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html#a1d1efc4bd7bee3a0cf9366536feb463a">MCFClass::SetPar()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceMCFClass__di__unipi__it.html">MCFClass_di_unipi_it</a></li><li class="navelem"><a class="el" href="classMCFClass__di__unipi__it_1_1MCFClass.html">MCFClass</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
